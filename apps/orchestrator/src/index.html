<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>nagomi</title>
    <script>
      (() => {
        try {
          const params = new URLSearchParams(window.location.search);
          if (params.get('view') === 'terminal') {
            document.documentElement.classList.add('terminal-only');
          }
          const storedThemeMode = localStorage.getItem('nagomi_theme_mode') || '';
          const storedThemePalette = localStorage.getItem('nagomi_theme_palette') || '';
          const queryThemeMode = params.get('theme') || '';
          const queryThemePalette = params.get('palette') || '';
          const prefersDark =
            typeof window.matchMedia === 'function' &&
            window.matchMedia('(prefers-color-scheme: dark)').matches;
          const themeMode =
            queryThemeMode === 'light' || queryThemeMode === 'dark'
              ? queryThemeMode
              : storedThemeMode === 'light' || storedThemeMode === 'dark'
              ? storedThemeMode
              : prefersDark
              ? 'dark'
              : 'light';
          const darkPalettes = new Set(['dark-ink', 'dark-ocean', 'dark-ember', 'dark-mono']);
          const lightPalettes = new Set([
            'light-sand',
            'light-sage',
            'light-sky',
            'light-mono',
          ]);
          const defaultPalette = themeMode === 'dark' ? 'dark-ink' : 'light-sand';
          const preferredPalette = queryThemePalette || storedThemePalette;
          const themePalette =
            themeMode === 'dark'
              ? darkPalettes.has(preferredPalette)
                ? preferredPalette
                : defaultPalette
              : lightPalettes.has(preferredPalette)
              ? preferredPalette
              : defaultPalette;
          document.documentElement.dataset.theme = themeMode;
          document.documentElement.dataset.themePalette = themePalette;
        } catch {
          // no-op
        }
      })();
    </script>
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700&family=JetBrains+Mono:wght@400;600&display=swap');

      :root {
        color-scheme: light;
        --bg: #f0ede7;
        --bg-2: #e7e1d7;
        --ink: #1f2429;
        --ink-soft: #4a4f55;
        --muted: #7a7f85;
        --accent: #1f7a8c;
        --accent-2: #f26a3d;
        --bg-accent-1: rgba(31, 122, 140, 0.07);
        --bg-accent-2: rgba(242, 106, 61, 0.06);
        --panel: #f7f3ed;
        --panel-border: #d8d0c5;
        --shadow: 0 18px 36px rgba(27, 25, 22, 0.12);
        --settings-panel: #f7f3ed;
        --settings-card: #fbf6ee;
        --settings-border: #d8d0c5;
        --settings-ink: #1f2429;
        --settings-ink-soft: #4a4f55;
        --settings-note: #7a7f85;
        --settings-shadow: 0 16px 28px rgba(27, 25, 22, 0.14);
        --settings-accent: #1f7a8c;
        --settings-accent-border: rgba(31, 122, 140, 0.55);
        --settings-accent-bg: rgba(31, 122, 140, 0.08);
        --toggle-track-off: rgba(0, 0, 0, 0.12);
        --toggle-thumb: #ffffff;
        --radius: 18px;
        --terminal-state-running: 66, 133, 244;
        --terminal-state-need-input: 242, 166, 66;
        --terminal-state-success: 72, 187, 120;
        --terminal-state-fail: 220, 80, 80;
      }

      html[data-theme='dark'] {
        color-scheme: dark;
        --bg: #0c1116;
        --bg-2: #121a22;
        --ink: #e7ecf2;
        --ink-soft: #b0bac6;
        --muted: #8b96a4;
        --accent: #4db3c7;
        --accent-2: #f28a63;
        --bg-accent-1: rgba(77, 179, 199, 0.16);
        --bg-accent-2: rgba(242, 138, 99, 0.12);
        --panel: #151c24;
        --panel-border: #2b3440;
        --shadow: 0 22px 40px rgba(0, 0, 0, 0.5);
        --settings-panel: #11161b;
        --settings-card: #181f27;
        --settings-border: #2b3440;
        --settings-ink: #e7ecf2;
        --settings-ink-soft: #b0bac6;
        --settings-note: #8b96a4;
        --settings-shadow: 0 22px 36px rgba(0, 0, 0, 0.45);
        --settings-accent: #4db3c7;
        --settings-accent-border: rgba(77, 179, 199, 0.55);
        --settings-accent-bg: rgba(77, 179, 199, 0.14);
        --toggle-track-off: rgba(255, 255, 255, 0.18);
        --toggle-thumb: #f6f1e6;
      }

      html[data-theme='light'][data-theme-palette='light-sand'] {
        --bg: #f0ede7;
        --bg-2: #e7e1d7;
        --accent: #1f7a8c;
        --accent-2: #f26a3d;
        --panel: #f7f3ed;
        --panel-border: #d8d0c5;
        --settings-panel: #f7f3ed;
        --settings-card: #fbf6ee;
        --settings-border: #d8d0c5;
        --settings-accent: #1f7a8c;
        --settings-accent-border: rgba(31, 122, 140, 0.55);
        --settings-accent-bg: rgba(31, 122, 140, 0.08);
      }

      html[data-theme='light'][data-theme-palette='light-sage'] {
        --bg: #eef3ec;
        --bg-2: #e2ebdf;
        --accent: #2c7a4f;
        --accent-2: #c57b2e;
        --panel: #f3f8f1;
        --panel-border: #c8d9cb;
        --settings-panel: #f3f8f1;
        --settings-card: #f7fbf6;
        --settings-border: #c8d9cb;
        --settings-accent: #2c7a4f;
        --settings-accent-border: rgba(44, 122, 79, 0.5);
        --settings-accent-bg: rgba(44, 122, 79, 0.1);
      }

      html[data-theme='light'][data-theme-palette='light-sky'] {
        --bg: #edf2f8;
        --bg-2: #dfe9f4;
        --accent: #2e5f9e;
        --accent-2: #b6684b;
        --panel: #f4f8fc;
        --panel-border: #c6d5e8;
        --settings-panel: #f4f8fc;
        --settings-card: #f8fbff;
        --settings-border: #c6d5e8;
        --settings-accent: #2e5f9e;
        --settings-accent-border: rgba(46, 95, 158, 0.52);
        --settings-accent-bg: rgba(46, 95, 158, 0.1);
      }

      html[data-theme='light'][data-theme-palette='light-mono'] {
        --bg: #f5f5f5;
        --bg-2: #e8e8e8;
        --accent: #222222;
        --accent-2: #5a5a5a;
        --panel: #ffffff;
        --panel-border: #bdbdbd;
        --settings-panel: #f4f4f4;
        --settings-card: #ffffff;
        --settings-border: #bdbdbd;
        --settings-accent: #1a1a1a;
        --settings-accent-border: rgba(26, 26, 26, 0.45);
        --settings-accent-bg: rgba(26, 26, 26, 0.08);
      }

      html[data-theme='dark'][data-theme-palette='dark-ink'] {
        --bg: #0c1116;
        --bg-2: #121a22;
        --accent: #4db3c7;
        --accent-2: #f28a63;
        --panel: #151c24;
        --panel-border: #2b3440;
        --settings-panel: #11161b;
        --settings-card: #181f27;
        --settings-border: #2b3440;
        --settings-accent: #4db3c7;
        --settings-accent-border: rgba(77, 179, 199, 0.55);
        --settings-accent-bg: rgba(77, 179, 199, 0.14);
      }

      html[data-theme='dark'][data-theme-palette='dark-ocean'] {
        --bg: #08121a;
        --bg-2: #0f1f2b;
        --accent: #4aa7d8;
        --accent-2: #58c2a7;
        --panel: #10202d;
        --panel-border: #274152;
        --settings-panel: #0d1a24;
        --settings-card: #132534;
        --settings-border: #274152;
        --settings-accent: #4aa7d8;
        --settings-accent-border: rgba(74, 167, 216, 0.56);
        --settings-accent-bg: rgba(74, 167, 216, 0.16);
      }

      html[data-theme='dark'][data-theme-palette='dark-ember'] {
        --bg: #14100f;
        --bg-2: #1d1614;
        --accent: #d3885a;
        --accent-2: #c6a14f;
        --panel: #241b18;
        --panel-border: #3e2f2a;
        --settings-panel: #1d1513;
        --settings-card: #2a1f1b;
        --settings-border: #3e2f2a;
        --settings-accent: #d3885a;
        --settings-accent-border: rgba(211, 136, 90, 0.58);
        --settings-accent-bg: rgba(211, 136, 90, 0.16);
      }

      html[data-theme='dark'][data-theme-palette='dark-mono'] {
        --bg: #090909;
        --bg-2: #111111;
        --accent: #f1f1f1;
        --accent-2: #b8b8b8;
        --panel: #151515;
        --panel-border: #3c3c3c;
        --settings-panel: #111111;
        --settings-card: #191919;
        --settings-border: #3c3c3c;
        --settings-accent: #ededed;
        --settings-accent-border: rgba(237, 237, 237, 0.45);
        --settings-accent-bg: rgba(237, 237, 237, 0.12);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: 'Space Grotesk', sans-serif;
        color: var(--ink);
        background: radial-gradient(circle at 10% 20%, var(--bg-2), var(--bg)) fixed,
          linear-gradient(135deg, var(--bg-accent-1), var(--bg-accent-2));
        min-height: 100vh;
      }

      .app {
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        padding: 28px 32px 32px;
        gap: 20px;
      }

      header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
      }

      header nav {
        display: flex;
        gap: 8px;
      }

      .mode-chip {
        border: 1px solid var(--panel-border);
        background: var(--panel);
        color: var(--ink);
        padding: 6px 12px;
        border-radius: 999px;
        font-size: 12px;
        cursor: pointer;
      }

      .mode-chip.active {
        background: var(--accent);
        color: #fff;
        border-color: transparent;
      }

      .brand {
        display: flex;
        align-items: center;
        gap: 14px;
      }

      .brand-mark {
        width: 42px;
        height: 42px;
        border-radius: 14px;
        background: linear-gradient(140deg, var(--accent), #67b99a);
        box-shadow: 0 8px 16px rgba(31, 122, 140, 0.25);
      }

      .brand h1 {
        margin: 0;
        font-size: 26px;
        letter-spacing: 0.3px;
      }

      .brand span {
        display: block;
        font-size: 13px;
        color: var(--ink-soft);
        letter-spacing: 0.1em;
        text-transform: uppercase;
      }

      .toolbar {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .pill {
        border-radius: 999px;
        padding: 8px 16px;
        background: var(--panel);
        border: 1px solid var(--panel-border);
        font-size: 13px;
        color: var(--ink-soft);
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }

      .pill strong {
        color: var(--ink);
      }

      .main {
        flex: 1;
        display: grid;
        grid-template-columns: minmax(0, 2.2fr) minmax(280px, 1fr);
        gap: 20px;
      }

      .hidden {
        display: none !important;
      }

      .lane {
        background: var(--panel);
        border-radius: var(--radius);
        border: 1px solid var(--panel-border);
        box-shadow: var(--shadow);
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .lane-header {
        padding: 16px 20px;
        border-bottom: 1px solid var(--panel-border);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .lane-header h2 {
        margin: 0;
        font-size: 18px;
      }

      .lane-body {
        padding: 18px 20px 0;
        flex: 1;
        display: flex;
        flex-direction: column;
      }

      .output {
        flex: 1;
        overflow: auto;
        background: #111820;
        border-radius: 14px;
        padding: 18px 20px;
        color: #f5f5f5;
        font-family: ui-monospace, 'Cascadia Mono', Consolas, 'SFMono-Regular', Menlo, Monaco,
          'Liberation Mono', 'DejaVu Sans Mono', monospace;
        font-size: 13px;
        line-height: 1.6;
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.08);
      }

      .output-line {
        white-space: pre-wrap;
      }

      .output-line.system {
        color: #8fb9ff;
      }

      .output-line.user {
        color: #f6d28b;
      }

      .input-area {
        margin-top: 16px;
        display: flex;
        gap: 12px;
        align-items: flex-end;
      }

      .input-area textarea {
        flex: 1;
        resize: none;
        min-height: 54px;
        padding: 12px 14px;
        border-radius: 12px;
        border: 1px solid var(--panel-border);
        font-family: 'Space Grotesk', sans-serif;
        font-size: 14px;
        background: var(--panel);
        color: var(--ink);
      }

      .input-area button {
        background: var(--accent);
        color: #fff;
        border: none;
        border-radius: 12px;
        padding: 12px 18px;
        font-size: 14px;
        cursor: pointer;
        box-shadow: 0 10px 20px rgba(31, 122, 140, 0.25);
      }

      .sidebar {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .run-board {
        background: var(--panel);
        border-radius: var(--radius);
        border: 1px solid var(--panel-border);
        padding: 18px 20px 20px;
        box-shadow: var(--shadow);
      }

      .run-board h2 {
        margin: 0 0 14px;
        font-size: 18px;
      }

      .tiles {
        display: grid;
        gap: 14px;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      }

      .tile {
        background: #121821;
        color: #f5f5f5;
        border-radius: 14px;
        padding: 16px;
        min-height: 120px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.08);
        transition: transform 200ms ease, box-shadow 200ms ease;
        cursor: pointer;
        user-select: none;
        -webkit-user-select: none;
      }

      .tile-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
      }

      .tile-face {
        width: 26px;
        height: 26px;
        border-radius: 8px;
        background: #1f2933;
        display: grid;
        place-items: center;
        font-size: 10px;
        color: #f6d28b;
      }

      .tile-status {
        font-size: 10px;
        color: #9fb3c8;
        text-transform: uppercase;
        letter-spacing: 0.1em;
      }

      .tile-output {
        margin-top: 10px;
        font-family: ui-monospace, 'Cascadia Mono', Consolas, 'SFMono-Regular', Menlo, Monaco,
          'Liberation Mono', 'DejaVu Sans Mono', monospace;
        font-size: 10px;
        line-height: 1.4;
        color: #cbd5e1;
        opacity: 0.85;
      }

      .tile.focused {
        transform: scale(1.8);
        z-index: 2;
        box-shadow: 0 16px 30px rgba(18, 24, 33, 0.35);
      }

      .tile small {
        color: #9fb3c8;
        font-size: 12px;
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }

      .terminal-board {
        background: var(--panel);
        border-radius: var(--radius);
        border: 1px solid var(--panel-border);
        padding: 18px 20px 20px;
        box-shadow: var(--shadow);
        display: flex;
        flex-direction: column;
        gap: 12px;
        min-height: 70vh;
      }

      .terminal-shell {
        flex: 1;
        background: var(--panel);
        border-radius: 16px;
        padding: 12px;
        border: 1px solid var(--panel-border);
        display: flex;
        position: relative;
        overflow: hidden;
      }

      .terminal-shell::after {
        content: '';
        position: absolute;
        inset: 0;
        background: transparent;
        pointer-events: none;
        z-index: 2;
        transition: background 140ms ease;
      }

      .terminal-shell.state-running::after {
        background: rgba(var(--terminal-state-running), 0.45);
      }

      .terminal-shell.state-need-input::after {
        background: rgba(var(--terminal-state-need-input), 0.55);
      }

      .terminal-shell.state-success::after {
        background: rgba(var(--terminal-state-success), 0.35);
      }

      .terminal-shell.state-fail::after {
        background: rgba(var(--terminal-state-fail), 0.6);
      }

      .terminal-shell.state-running,
      .terminal-shell.state-need-input,
      .terminal-shell.state-success,
      .terminal-shell.state-fail {
        box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.08);
      }

      .terminal-shell.state-running {
        box-shadow: 0 0 0 2px rgba(var(--terminal-state-running), 0.9);
      }

      .terminal-shell.state-need-input {
        box-shadow: 0 0 0 2px rgba(var(--terminal-state-need-input), 0.9);
      }

      .terminal-shell.state-success {
        box-shadow: 0 0 0 2px rgba(var(--terminal-state-success), 0.9);
      }

      .terminal-shell.state-fail {
        box-shadow: 0 0 0 2px rgba(var(--terminal-state-fail), 0.9);
      }

      .terminal-watcher {
        position: absolute;
        right: 18px;
        bottom: 18px;
        width: 96px;
        height: 192px;
        display: none;
        background: transparent;
        border: none;
        box-shadow: none;
        z-index: 4;
        user-select: none;
        pointer-events: none;
      }

      .terminal-watcher img {
        width: 96px;
        height: 192px;
        display: block;
        image-rendering: auto;
      }

      html.watcher-only,
      body.watcher-only {
        background: transparent;
      }

      body.watcher-only {
        overflow: hidden;
      }

      body.watcher-only .app {
        background: transparent;
      }

      body.watcher-only header,
      body.watcher-only .chat-main,
      body.watcher-only .chat-toolbar,
      body.watcher-only .run-board,
      body.watcher-only .settings-board,
      body.watcher-only .mode-switch,
      body.watcher-only #terminal-container,
      body.watcher-only .terminal-debug-badge,
      body.watcher-only .terminal-debug-action,
      body.watcher-only h2 {
        display: none !important;
      }

      body.watcher-only .terminal-board {
        display: block !important;
        background: transparent;
      }

      body.watcher-only .terminal-shell {
        background: transparent;
        border: none;
        box-shadow: none;
      }

      body.watcher-only .terminal-watcher {
        display: block;
        position: fixed;
        right: 16px;
        bottom: 16px;
      }

      .terminal-debug-badge {
        position: absolute;
        left: 18px;
        right: 140px;
        bottom: 18px;
        padding: 6px 8px;
        border-radius: 10px;
        background: rgba(15, 23, 42, 0.8);
        border: 1px solid rgba(255, 255, 255, 0.12);
        color: #e2e8f0;
        font-size: 10px;
        font-family: 'JetBrains Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          'Liberation Mono', 'Courier New', monospace;
        max-width: calc(100% - 180px);
        z-index: 5;
        pointer-events: none;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .terminal-debug-action {
        position: absolute;
        left: 18px;
        top: 18px;
        padding: 6px 10px;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        background: rgba(15, 23, 42, 0.7);
        color: #e2e8f0;
        font-size: 11px;
        font-family: 'Space Grotesk', sans-serif;
        cursor: pointer;
        z-index: 5;
      }

      .terminal-debug-action[data-role='terminal-debug-screenshot'] {
        top: 52px;
      }

      .terminal-debug-action:active {
        transform: translateY(1px);
      }

      .terminal-debug-toggle {
        position: absolute;
        right: 18px;
        top: 18px;
        z-index: 8;
        border-radius: 999px;
        padding: 6px 10px;
        font-size: 11px;
        font-weight: 600;
        border: 1px solid rgba(142, 138, 120, 0.6);
        background: rgba(25, 26, 24, 0.78);
        color: #f7f2e6;
        cursor: pointer;
        letter-spacing: 0.01em;
      }

      .terminal-debug-toggle:hover {
        background: rgba(36, 38, 33, 0.92);
      }

      .terminal-shell.debug-ui-hidden .terminal-debug-badge,
      .terminal-shell.debug-ui-hidden .terminal-debug-action {
        display: none;
      }

      #terminal-container {
        flex: 1;
        height: 100%;
      }

      .terminal-shell .xterm {
        height: 100%;
        position: relative;
        z-index: 1;
      }

      .panel {
        background: var(--panel);
        border-radius: var(--radius);
        border: 1px solid var(--panel-border);
        padding: 18px 20px;
        box-shadow: var(--shadow);
      }

      .settings-board {
        background: var(--settings-panel);
        border-radius: var(--radius);
        border: 1px solid var(--settings-border);
        padding: 22px 24px;
        box-shadow: var(--settings-shadow);
        display: flex;
        flex-direction: column;
        gap: 16px;
        color: var(--settings-ink);
        accent-color: var(--settings-accent);
        max-width: 1040px;
        width: 100%;
        margin: 0 auto;
      }

      .settings-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
        gap: 16px;
      }

      .settings-card {
        background: var(--settings-card);
        border: 1px solid var(--settings-border);
        border-radius: 16px;
        padding: 16px;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .settings-card--agent {
        border-color: var(--settings-accent-border);
        background: linear-gradient(
            135deg,
            var(--settings-accent-bg),
            transparent 55%
          ),
          var(--settings-card);
      }

      .settings-card--appearance {
        border-color: var(--settings-accent-border);
        background: linear-gradient(
            135deg,
            var(--settings-accent-bg),
            transparent 55%
          ),
          var(--settings-card);
        grid-column: 1 / -1;
      }

      .settings-card--windows {
        border-color: var(--settings-accent-border);
        background: linear-gradient(
            135deg,
            var(--settings-accent-bg),
            transparent 55%
          ),
          var(--settings-card);
      }

      .settings-card h3 {
        margin: 0;
        font-size: 15px;
      }

      .settings-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        font-size: 13px;
        color: var(--settings-ink-soft);
      }

      .settings-board .settings-row {
        justify-content: flex-start;
        gap: 12px;
        display: grid;
        grid-template-columns: minmax(0, 160px) minmax(0, 1fr);
        align-items: center;
      }

      .settings-board .settings-row > span {
        min-width: 0;
      }

      .settings-row--single {
        justify-content: flex-start;
        display: flex !important;
      }

      .settings-note {
        margin: 0;
        font-size: 12px;
        color: var(--settings-note);
      }

      .settings-note-line {
        display: block;
        margin-top: 4px;
      }

      .settings-note-line:first-child {
        margin-top: 0;
      }

      .settings-row strong {
        color: var(--settings-ink);
      }

      .settings-row select,
      .settings-row input[type="number"],
      .settings-row input[type="text"] {
        width: 100%;
        border: 1px solid var(--settings-border);
        border-radius: 8px;
        padding: 4px 6px;
        background: var(--settings-panel);
        color: var(--settings-ink);
        min-width: 0;
      }

      .settings-row input[type="range"] {
        width: 100%;
      }

      .settings-upload {
        display: flex;
        flex-direction: column;
        gap: 8px;
        font-size: 13px;
        color: var(--settings-ink-soft);
      }

      .settings-upload input[type="file"] {
        font-size: 12px;
      }

      .character-list {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 10px;
      }

      .character-card {
        border: 1px dashed var(--settings-border);
        border-radius: 12px;
        padding: 10px;
        background: var(--settings-panel);
        font-size: 12px;
        color: var(--settings-ink-soft);
      }

      .character {
        flex: 1;
        min-height: 220px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }

      .avatar {
        width: 100%;
        height: 220px;
        border-radius: 16px;
        background: linear-gradient(160deg, #f1c27d, #f7e0b4 45%, #fff5df);
        border: 1px dashed #d2b48c;
        display: grid;
        place-items: center;
        font-size: 14px;
        color: #7b5b2d;
        letter-spacing: 0.1em;
      }

      .status-line {
        margin-top: 12px;
        font-size: 13px;
        color: var(--ink-soft);
      }

      .phase-controls {
        margin-top: 12px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .phase-controls button {
        border: 1px solid var(--panel-border);
        background: var(--panel);
        color: var(--ink);
        padding: 6px 10px;
        border-radius: 999px;
        font-size: 11px;
        cursor: pointer;
      }

      .toggle {
        border: 1px solid var(--panel-border);
        background: var(--panel);
        color: var(--ink);
        padding: 8px 12px;
        border-radius: 10px;
        font-size: 12px;
        cursor: pointer;
      }

      .toggle-switch {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        font-weight: 600;
      }

      .toggle-switch .toggle-state {
        font-size: 11px;
        letter-spacing: 0.05em;
        text-transform: uppercase;
        min-width: 28px;
        text-align: left;
        color: var(--settings-ink);
      }

      .toggle-switch .toggle-track {
        width: 36px;
        height: 18px;
        border-radius: 999px;
        background: var(--toggle-track-off);
        border: 1px solid var(--panel-border);
        position: relative;
        transition: background 160ms ease, border-color 160ms ease;
      }

      .toggle-switch .toggle-thumb {
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: var(--toggle-thumb);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        position: absolute;
        top: 50%;
        left: 2px;
        transform: translateY(-50%);
        transition: left 160ms ease;
      }

      .toggle-switch[data-state='on'] .toggle-track {
        background: var(--settings-accent);
        border-color: var(--settings-accent-border);
      }

      .toggle-switch[data-state='on'] .toggle-thumb {
        left: calc(100% - 16px);
      }

      .toggle-switch[data-state='off'] .toggle-state {
        color: var(--settings-ink-soft);
      }

      .settings-board .toggle {
        border-color: var(--settings-border);
        background: var(--settings-panel);
        color: var(--settings-ink);
      }

      html[data-theme='dark'] .settings-board {
        color-scheme: dark;
      }

      @media (max-width: 980px) {
        .main {
          grid-template-columns: 1fr;
        }
        .sidebar {
          order: -1;
        }
      }

      @media (max-width: 860px) {
        .settings-board {
          padding: 16px;
          width: 100%;
        }
        .settings-grid {
          grid-template-columns: 1fr;
        }
        .settings-board .settings-row {
          grid-template-columns: 1fr;
          gap: 8px;
        }
      }

      body.settings-only .app {
        padding: 12px 14px 14px;
        gap: 10px;
      }

      body.settings-only header {
        display: none;
      }

      body.settings-only .settings-board {
        max-width: none;
        margin: 0;
      }

      html.terminal-only body,
      body.terminal-only {
        background: var(--bg);
        overflow: hidden;
      }

      html.terminal-only,
      html.terminal-only body,
      body.terminal-only {
        height: 100%;
        overflow: hidden;
      }

      html.terminal-only .app,
      body.terminal-only .app {
        padding: 0;
        gap: 0;
        height: 100%;
        min-height: 100%;
      }

      html.terminal-only header,
      html.terminal-only .run-board,
      html.terminal-only .settings-board,
      html.terminal-only .main,
      body.terminal-only header,
      body.terminal-only .run-board,
      body.terminal-only .settings-board,
      body.terminal-only .main {
        display: none !important;
      }

      html.terminal-only .terminal-board.hidden {
        display: flex !important;
      }

      html.terminal-only .terminal-board,
      body.terminal-only .terminal-board {
        border-radius: 0;
        border: none;
        padding: 0;
        box-shadow: none;
        min-height: 100%;
        height: 100%;
        width: 100%;
      }

      html.terminal-only .terminal-board h2,
      body.terminal-only .terminal-board h2 {
        display: none;
      }

      html.terminal-only .terminal-shell,
      body.terminal-only .terminal-shell {
        border-radius: 0;
        border: none;
        padding: 0;
        height: 100%;
        width: 100%;
        overflow: hidden;
        position: relative;
      }

      html.terminal-only #terminal-container,
      body.terminal-only #terminal-container {
        height: 100%;
        width: 100%;
        overflow: hidden;
      }

    </style>
    <link rel="stylesheet" href="vendor/xterm/xterm.css" />
  </head>
  <body>
    <div class="app">
      <header>
        <div class="brand">
          <div class="brand-mark" aria-hidden="true"></div>
          <div>
            <h1>nagomi</h1>
            <span data-role="mode-subtitle" data-i18n="mode.chat">chat mode</span>
          </div>
        </div>
        <nav data-role="mode-switch">
          <button
            class="mode-chip active"
            data-role="mode-chip"
            data-mode="chat"
            data-i18n="nav.chat"
            type="button"
          >
            chat
          </button>
          <button
            class="mode-chip"
            data-role="mode-chip"
            data-mode="run"
            data-i18n="nav.run"
            type="button"
          >
            run
          </button>
        </nav>
        <div class="toolbar" data-role="chat-toolbar">
          <div class="pill">
            <span data-i18n="toolbar.follow">follow</span>
            <strong id="follow-state">on</strong>
          </div>
          <button class="toggle" data-role="follow-toggle" data-i18n="toolbar.follow_toggle" type="button">
            toggle follow
          </button>
        </div>
      </header>

      <div class="main" data-role="chat-main">
        <section class="lane">
          <div class="lane-header">
            <h2 data-i18n="chat.lane_title">conversation lane</h2>
            <span class="pill" data-i18n="chat.session_draft">session: draft</span>
          </div>
          <div class="lane-body">
            <div class="output" data-role="chat-lane" id="output">
              <div class="output-line system" data-i18n="chat.system_ready">
                [system] lane ready
              </div>
              <div class="output-line user" data-i18n="chat.user_hint">
                [you] type a command to continue
              </div>
            </div>
            <div class="input-area">
              <textarea
                id="chat-input"
                data-role="chat-input"
                data-i18n-placeholder="chat.input_placeholder"
                placeholder="type here and press send"
              ></textarea>
              <button id="send-btn" type="button" data-i18n="chat.send">
                send
              </button>
            </div>
          </div>
        </section>

        <aside class="sidebar">
          <div class="panel">
            <h3 data-i18n="status.title">status</h3>
            <p class="status-line" data-i18n="status.phase_idle">phase: idle</p>
            <p class="status-line" data-i18n="status.silence_timeout">
              silence timeout: 30s
            </p>
          </div>
          <div class="panel character">
            <div class="avatar" data-i18n="character.title">character</div>
            <p class="status-line">
              <span data-i18n="character.expression">expression:</span>
              <strong data-role="character-phase">idle</strong>
            </p>
            <div class="phase-controls" data-role="phase-controls">
              <button type="button" data-role="phase-button" data-phase="idle" data-i18n="phase.idle">
                idle
              </button>
              <button type="button" data-role="phase-button" data-phase="thinking" data-i18n="phase.thinking">
                thinking
              </button>
              <button type="button" data-role="phase-button" data-phase="success" data-i18n="phase.success">
                success
              </button>
              <button type="button" data-role="phase-button" data-phase="error" data-i18n="phase.error">
                error
              </button>
              <button type="button" data-role="phase-button" data-phase="need_input" data-i18n="phase.need_input">
                need input
              </button>
            </div>
          </div>
        </aside>
      </div>

      <section class="run-board hidden" data-role="run-board">
        <h2 data-i18n="run.title">session board</h2>
        <div class="settings-row" style="justify-content: flex-start; gap: 12px; margin-bottom: 12px;">
          <button class="toggle" data-role="run-arrange" data-i18n="run.arrange" type="button">
            arrange windows
          </button>
          <span class="status-line" data-i18n="run.layout_hint">
            tile layout: 1 row / 2 rows (5+) / 3 rows (9+)
          </span>
        </div>
        <div class="tiles" data-role="run-tiles">
          <div class="tile" data-role="run-tile" data-session="session-01">
            <div class="tile-header">
              <small data-i18n="run.session_01">session 01</small>
              <span class="tile-status" data-i18n="status.running">running</span>
            </div>
            <div class="tile-header">
              <strong data-i18n="run.sample.build">build</strong>
              <span class="tile-face" data-role="run-tile-face">:)</span>
            </div>
            <div class="tile-output" data-i18n="run.sample.build_log">[log] cargo build ...</div>
          </div>
          <div class="tile" data-role="run-tile" data-session="session-02">
            <div class="tile-header">
              <small data-i18n="run.session_02">session 02</small>
              <span class="tile-status" data-i18n="status.idle">idle</span>
            </div>
            <div class="tile-header">
              <strong data-i18n="run.sample.lint">lint</strong>
              <span class="tile-face" data-role="run-tile-face">:|</span>
            </div>
            <div class="tile-output" data-i18n="run.sample.lint_log">[log] waiting ...</div>
          </div>
          <div class="tile" data-role="run-tile" data-session="session-03">
            <div class="tile-header">
              <small data-i18n="run.session_03">session 03</small>
              <span class="tile-status" data-i18n="status.success">success</span>
            </div>
            <div class="tile-header">
              <strong data-i18n="run.sample.test">test</strong>
              <span class="tile-face" data-role="run-tile-face">:D</span>
            </div>
            <div class="tile-output" data-i18n="run.sample.test_log">[log] ok 124 passed</div>
          </div>
          <div class="tile" data-role="run-tile" data-session="session-04">
            <div class="tile-header">
              <small data-i18n="run.session_04">session 04</small>
              <span class="tile-status" data-i18n="status.error">error</span>
            </div>
            <div class="tile-header">
              <strong data-i18n="run.sample.ship">ship</strong>
              <span class="tile-face" data-role="run-tile-face">:(</span>
            </div>
            <div class="tile-output" data-i18n="run.sample.ship_log">[log] failed: auth</div>
          </div>
        </div>
      </section>

      <section class="terminal-board hidden" data-role="terminal-board">
        <h2 data-i18n="terminal.title">terminal</h2>
        <div class="terminal-shell">
          <div id="terminal-container" data-role="terminal-container"></div>
          <div class="terminal-watcher" data-role="terminal-watcher" title="running">
            <img
              data-role="terminal-watcher-image"
              alt="watcher"
              src="assets/watcher/nagomisan_full_idle.png"
              width="96"
              height="192"
            />
          </div>
          <div class="terminal-debug-badge" data-role="terminal-debug-badge">state=idle</div>
          <button
            class="terminal-debug-action"
            data-role="terminal-debug-save"
            data-i18n="debug.save_snapshot"
            type="button"
          >
            save debug snapshot
          </button>
          <button
            class="terminal-debug-action"
            data-role="terminal-debug-screenshot"
            data-i18n="debug.save_screenshot"
            type="button"
          >
            save debug screenshot
          </button>
          <button
            class="terminal-debug-toggle"
            data-role="terminal-debug-toggle"
            data-i18n="debug.ui_on"
            type="button"
          >
            debug ui: on
          </button>
        </div>
      </section>

      <section class="settings-board hidden" data-role="settings-board">
        <h2 data-i18n="settings.title">Settings</h2>
        <div class="settings-grid">
          <div class="settings-card settings-card--appearance">
            <h3 data-i18n="settings.appearance.title">appearance</h3>
            <div class="settings-row">
              <span data-i18n="settings.appearance.theme">theme</span>
              <select data-role="settings-terminal-theme">
                <option value="light-sand" data-i18n="settings.theme.palette.light_sand">light: sand</option>
                <option value="light-sage" data-i18n="settings.theme.palette.light_sage">light: sage</option>
                <option value="light-sky" data-i18n="settings.theme.palette.light_sky">light: sky</option>
                <option value="light-mono" data-i18n="settings.theme.palette.light_mono">light: mono</option>
                <option value="dark-ink" data-i18n="settings.theme.palette.dark_ink">dark: ink</option>
                <option value="dark-ocean" data-i18n="settings.theme.palette.dark_ocean">dark: ocean</option>
                <option value="dark-ember" data-i18n="settings.theme.palette.dark_ember">dark: ember</option>
                <option value="dark-mono" data-i18n="settings.theme.palette.dark_mono">dark: mono</option>
              </select>
            </div>
            <div class="settings-row">
              <span data-i18n="settings.appearance.font_family">font family</span>
              <select data-role="settings-terminal-font">
                <option
                  value="ui-monospace, 'Cascadia Mono', Consolas, 'SFMono-Regular', Menlo, Monaco, 'Liberation Mono', 'DejaVu Sans Mono', monospace"
                  data-i18n="settings.font.system_default"
                >
                  system default
                </option>
                <option
                  value="'Cascadia Mono', 'Cascadia Code', Consolas, monospace"
                  data-i18n="settings.font.cascadia"
                >
                  Cascadia Mono
                </option>
                <option
                  value="Consolas, 'Cascadia Mono', 'SFMono-Regular', Menlo, Monaco, monospace"
                  data-i18n="settings.font.consolas"
                >
                  Consolas
                </option>
              </select>
            </div>
            <div class="settings-row settings-row--single">
              <button
                class="toggle"
                data-role="settings-terminal-font-refresh"
                data-i18n="settings.font.load_os"
                type="button"
              >
                OSからフォントを取得
              </button>
            </div>
            <p
              class="settings-note"
              data-role="settings-terminal-font-status"
              data-i18n="settings.font.status_idle"
            >
              未読み込み
            </p>
            <div class="settings-row">
              <span data-i18n="settings.appearance.font_size">font size</span>
              <input
                type="number"
                min="10"
                max="24"
                step="1"
                value="18"
                data-role="settings-terminal-font-size"
              />
            </div>
            <div class="settings-row">
              <span data-i18n="settings.appearance.scrollback">scrollback</span>
              <input
                type="number"
                min="1000"
                step="1000"
                value="5000"
                data-role="settings-terminal-scrollback"
              />
            </div>
            <div class="settings-row">
              <span data-i18n="settings.appearance.copy_on_select">copy on select</span>
              <button
                class="toggle toggle-switch"
                data-role="settings-terminal-copy"
                type="button"
              >
                <span class="toggle-state" data-role="settings-terminal-copy-state">on</span>
                <span class="toggle-track" aria-hidden="true">
                  <span class="toggle-thumb"></span>
                </span>
              </button>
            </div>
          </div>

          <div class="settings-card settings-card--windows hidden" data-role="settings-windows-card">
            <h3 data-i18n="settings.windows.title">windows</h3>
            <div class="settings-row" data-role="settings-terminal-shell-row">
              <span data-i18n="settings.runtime.shell">terminal shell</span>
              <select data-role="settings-terminal-shell-kind">
                <option value="cmd" data-i18n="settings.runtime.shell.cmd">CMD</option>
                <option value="powershell" data-i18n="settings.runtime.shell.powershell">
                  PowerShell
                </option>
                <option value="wsl" data-i18n="settings.runtime.shell.wsl">WSL</option>
              </select>
            </div>
            <div class="settings-row hidden" data-role="settings-terminal-wsl-distro-row">
              <span data-i18n="settings.runtime.wsl_distro">WSL distro</span>
              <select data-role="settings-terminal-wsl-distro">
                <option value="" data-i18n="settings.runtime.wsl_default">default distro</option>
              </select>
            </div>
            <div class="settings-row">
              <span data-i18n="settings.runtime.internal_commands">:ng internal commands</span>
              <button
                class="toggle toggle-switch"
                data-role="settings-terminal-internal-commands"
                type="button"
              >
                <span class="toggle-state" data-role="settings-terminal-internal-commands-state">on</span>
                <span class="toggle-track" aria-hidden="true">
                  <span class="toggle-thumb"></span>
                </span>
              </button>
            </div>
            <div class="settings-row">
              <span data-i18n="settings.shortcuts.arrange">arrange shortcut</span>
              <input
                type="text"
                readonly
                data-role="settings-keybind-arrange"
                value="Ctrl+Shift+Y"
              />
            </div>
            <div class="settings-row">
              <span data-i18n="settings.shortcuts.focus_next">focus next shortcut</span>
              <input
                type="text"
                readonly
                data-role="settings-keybind-focus-next"
                value="Ctrl+Shift+J"
              />
            </div>
            <div class="settings-row">
              <span data-i18n="settings.shortcuts.focus_prev">focus prev shortcut</span>
              <input
                type="text"
                readonly
                data-role="settings-keybind-focus-prev"
                value="Ctrl+Shift+K"
              />
            </div>
            <p class="settings-note" data-i18n="settings.shortcuts.note">
              フィールドを選択してキーの組み合わせを押してください（Escで既定値に戻します）
            </p>
          </div>

          <div class="settings-card settings-card--agent">
            <h3 data-i18n="settings.ai.title">AI Coding Agent</h3>
            <div class="settings-row">
              <span data-i18n="settings.ai.tool">使用ツール</span>
              <select data-role="settings-llm-tool">
                <option value="codex">codex</option>
                <option value="claude">claudecode</option>
                <option value="opencode">opencode</option>
              </select>
            </div>
            <div class="settings-row">
              <span data-i18n="settings.ai.judge">AIターミナル状態判定</span>
              <button
                class="toggle toggle-switch"
                data-role="settings-llm-toggle"
                type="button"
              >
                <span class="toggle-state" data-role="settings-llm-state">off</span>
                <span class="toggle-track" aria-hidden="true">
                  <span class="toggle-thumb"></span>
                </span>
              </button>
            </div>
            <p class="settings-note">
              <span class="settings-note-line" data-i18n="settings.ai.note_tool">
                選択したAIツールはターミナルの起動コマンド判別に使われます。
              </span>
              <span class="settings-note-line" data-i18n="settings.ai.note_judge_on">
                AI判定ONの場合は完了/入力待ちの通知と判定結果で状態検出します。
              </span>
              <span class="settings-note-line" data-i18n="settings.ai.note_judge_off">
                AI判定OFFの場合は端末出力のみで状態を判定します。
              </span>
            </p>
          </div>

          <div class="settings-card">
            <h3 data-i18n="settings.notifications.title">notifications</h3>
            <div class="settings-row">
              <span data-i18n="settings.notifications.toast">OS toast</span>
              <button
                class="toggle toggle-switch"
                data-role="settings-notify-toggle"
                type="button"
              >
                <span class="toggle-state" data-role="settings-notify-state">on</span>
                <span class="toggle-track" aria-hidden="true">
                  <span class="toggle-thumb"></span>
                </span>
              </button>
            </div>
            <div class="settings-row">
              <span data-i18n="settings.notifications.audio">audio</span>
              <button
                class="toggle toggle-switch"
                data-role="settings-audio-toggle"
                type="button"
              >
                <span class="toggle-state" data-role="settings-audio-state">on</span>
                <span class="toggle-track" aria-hidden="true">
                  <span class="toggle-thumb"></span>
                </span>
              </button>
            </div>
            <div class="settings-row">
              <span data-i18n="settings.notifications.volume">volume</span>
              <input
                type="range"
                min="0"
                max="1"
                step="0.05"
                value="0.8"
                data-role="settings-volume"
              />
            </div>
            <div class="settings-row">
              <span data-i18n="settings.notifications.silence">silence (ms)</span>
              <input
                type="number"
                min="500"
                step="100"
                value="3500"
                data-role="settings-silence-timeout"
              />
            </div>
          </div>

          <div class="settings-card">
            <h3 data-i18n="settings.character.title">character</h3>
            <div class="settings-row">
              <span data-i18n="settings.character.watcher">terminal character</span>
              <button
                class="toggle toggle-switch"
                data-role="settings-character-watcher"
                type="button"
              >
                <span class="toggle-state" data-role="settings-character-watcher-state">off</span>
                <span class="toggle-track" aria-hidden="true">
                  <span class="toggle-thumb"></span>
                </span>
              </button>
            </div>
            <div class="settings-upload">
              <span data-i18n="settings.character.upload">upload bundle (.zip)</span>
              <input type="file" accept=".zip" data-role="settings-character-upload" />
              <span data-role="settings-character-uploaded" data-i18n="settings.character.no_upload">
                no upload
              </span>
            </div>
            <div class="settings-row">
              <span data-i18n="settings.character.log_retention">log retention (lines)</span>
              <input
                type="number"
                min="1000"
                step="1000"
                value="20000"
                data-role="settings-log-retention"
              />
            </div>
            <div class="character-list" data-role="settings-character-list">
              <div class="character-card" data-i18n="settings.character.default">default</div>
            </div>
          </div>
        </div>
      </section>
    </div>

    <script src="vendor/xterm/xterm.js"></script>
    <script src="vendor/xterm/xterm-addon-fit.js"></script>
    <script src="vendor/xterm/xterm-addon-webgl.js"></script>
    <script src="terminal_observer.js"></script>
    <script src="agent_event_observer.js"></script>
    <script src="state_integrator.js"></script>
    <script>
      const I18N_RESOURCES = {
        ja: {
          'nav.chat': 'チャット',
          'nav.run': 'ラン',
          'mode.chat': 'チャットモード',
          'mode.run': 'ランモード',
          'mode.terminal': 'ターミナルモード',
          'toolbar.follow': '追従',
          'toolbar.follow_toggle': '追従切替',
          'chat.lane_title': '会話レーン',
          'chat.session_draft': 'セッション: draft',
          'chat.system_ready': '[system] レーン準備完了',
          'chat.user_hint': '[you] コマンドを入力してください',
          'chat.input_placeholder': 'ここに入力して送信',
          'chat.send': '送信',
          'status.title': 'ステータス',
          'status.phase_idle': 'フェーズ: idle',
          'status.silence_timeout': '無音タイムアウト: 30s',
          'status.running': '稼働中',
          'status.idle': '待機',
          'status.success': '成功',
          'status.error': 'エラー',
          'character.title': 'キャラクター',
          'character.expression': '表情:',
          'phase.idle': 'idle',
          'phase.thinking': 'thinking',
          'phase.success': 'success',
          'phase.error': 'error',
          'phase.need_input': 'need input',
          'run.title': 'セッションボード',
          'run.arrange': 'ウィンドウ整列',
          'run.layout_hint': 'タイル配置: 1行 / 2行 (5+) / 3行 (9+)',
          'run.session_01': 'セッション 01',
          'run.session_02': 'セッション 02',
          'run.session_03': 'セッション 03',
          'run.session_04': 'セッション 04',
          'run.sample.build': 'build',
          'run.sample.build_log': '[log] cargo build ...',
          'run.sample.lint': 'lint',
          'run.sample.lint_log': '[log] waiting ...',
          'run.sample.test': 'test',
          'run.sample.test_log': '[log] ok 124 passed',
          'run.sample.ship': 'ship',
          'run.sample.ship_log': '[log] failed: auth',
          'terminal.title': 'ターミナル',
          'debug.save_snapshot': 'デバッグスナップショット保存',
          'debug.save_screenshot': 'デバッグスクショ保存',
          'debug.ui_on': 'debug ui: on',
          'debug.ui_off': 'debug ui: off',
          'debug.status.saving': '保存中...',
          'debug.status.saved': '保存済み',
          'debug.status.failed': '失敗',
          'settings.title': '設定',
          'settings.appearance.title': '外観',
          'settings.appearance.theme': 'テーマ',
          'settings.appearance.font_family': 'フォント',
          'settings.appearance.font_size': 'フォントサイズ',
          'settings.appearance.scrollback': 'スクロールバック',
          'settings.appearance.copy_on_select': '選択コピー',
          'settings.runtime.shell': 'ターミナル起動方式',
          'settings.runtime.shell.cmd': 'CMD',
          'settings.runtime.shell.powershell': 'PowerShell',
          'settings.runtime.shell.wsl': 'WSL',
          'settings.runtime.wsl_distro': 'WSLディストロ',
          'settings.runtime.wsl_default': '既定のディストロ',
          'settings.runtime.internal_commands': ':ng 内蔵コマンド',
          'settings.windows.title': 'Windows',
          'settings.shortcuts.arrange': '整列ショートカット',
          'settings.shortcuts.focus_next': '次へ移動ショートカット',
          'settings.shortcuts.focus_prev': '前へ移動ショートカット',
          'settings.shortcuts.note':
            'フィールドを選択してキーの組み合わせを押してください（Escで既定値に戻します）',
          'settings.theme.palette.light_sand': 'ライト: Sand',
          'settings.theme.palette.light_sage': 'ライト: Sage',
          'settings.theme.palette.light_sky': 'ライト: Sky',
          'settings.theme.palette.light_mono': 'ライト: Mono',
          'settings.theme.palette.dark_ink': 'ダーク: Ink',
          'settings.theme.palette.dark_ocean': 'ダーク: Ocean',
          'settings.theme.palette.dark_ember': 'ダーク: Ember',
          'settings.theme.palette.dark_mono': 'ダーク: Mono',
          'settings.theme.dark': 'ダーク',
          'settings.theme.light': 'ライト',
          'settings.font.system_default': 'システム既定',
          'settings.font.cascadia': 'Cascadia Mono',
          'settings.font.consolas': 'Consolas',
          'settings.font.os_label': 'OSフォント',
          'settings.font.load_os': 'OSからフォントを取得',
          'settings.font.status_idle': '未読み込み',
          'settings.font.status_loading': '読み込み中...',
          'settings.font.status_loaded': 'OSフォント取得済み',
          'settings.font.status_unavailable': 'OSフォント取得は未対応',
          'settings.font.status_failed': 'OSフォント取得に失敗',
          'settings.ai.title': 'AI Coding Agent',
          'settings.ai.tool': '使用ツール',
          'settings.ai.judge': 'AIターミナル状態判定',
          'settings.ai.note_tool': '選択したAIツールはターミナルの起動コマンド判別に使われます。',
          'settings.ai.note_judge_on':
            'AIターミナル状態判定ONの場合は完了/入力待ちの通知と判定結果で状態検出します。',
          'settings.ai.note_judge_off':
            'AIターミナル状態判定OFFの場合は端末出力のみで状態を判定します。',
          'settings.notifications.title': '通知',
          'settings.notifications.toast': 'OS通知',
          'settings.notifications.audio': '音声',
          'settings.notifications.volume': '音量',
          'settings.notifications.silence': '無音 (ms)',
          'settings.character.title': 'キャラクター',
          'settings.character.watcher': 'ターミナルキャラクター表示',
          'settings.character.upload': 'バンドルアップロード (.zip)',
          'settings.character.no_upload': '未アップロード',
          'settings.character.log_retention': 'ログ保持 (行)',
          'settings.character.default': 'デフォルト',
          'toggle.on': 'ON',
          'toggle.off': 'OFF',
        },
        en: {
          'nav.chat': 'chat',
          'nav.run': 'run',
          'mode.chat': 'chat mode',
          'mode.run': 'run mode',
          'mode.terminal': 'terminal mode',
          'toolbar.follow': 'follow',
          'toolbar.follow_toggle': 'toggle follow',
          'chat.lane_title': 'conversation lane',
          'chat.session_draft': 'session: draft',
          'chat.system_ready': '[system] lane ready',
          'chat.user_hint': '[you] type a command to continue',
          'chat.input_placeholder': 'type here and press send',
          'chat.send': 'send',
          'status.title': 'status',
          'status.phase_idle': 'phase: idle',
          'status.silence_timeout': 'silence timeout: 30s',
          'status.running': 'running',
          'status.idle': 'idle',
          'status.success': 'success',
          'status.error': 'error',
          'character.title': 'character',
          'character.expression': 'expression:',
          'phase.idle': 'idle',
          'phase.thinking': 'thinking',
          'phase.success': 'success',
          'phase.error': 'error',
          'phase.need_input': 'need input',
          'run.title': 'session board',
          'run.arrange': 'arrange windows',
          'run.layout_hint': 'tile layout: 1 row / 2 rows (5+) / 3 rows (9+)',
          'run.session_01': 'session 01',
          'run.session_02': 'session 02',
          'run.session_03': 'session 03',
          'run.session_04': 'session 04',
          'run.sample.build': 'build',
          'run.sample.build_log': '[log] cargo build ...',
          'run.sample.lint': 'lint',
          'run.sample.lint_log': '[log] waiting ...',
          'run.sample.test': 'test',
          'run.sample.test_log': '[log] ok 124 passed',
          'run.sample.ship': 'ship',
          'run.sample.ship_log': '[log] failed: auth',
          'terminal.title': 'terminal',
          'debug.save_snapshot': 'save debug snapshot',
          'debug.save_screenshot': 'save debug screenshot',
          'debug.ui_on': 'debug ui: on',
          'debug.ui_off': 'debug ui: off',
          'debug.status.saving': 'saving...',
          'debug.status.saved': 'saved',
          'debug.status.failed': 'failed',
          'settings.title': 'Settings',
          'settings.appearance.title': 'appearance',
          'settings.appearance.theme': 'theme',
          'settings.appearance.font_family': 'font family',
          'settings.appearance.font_size': 'font size',
          'settings.appearance.scrollback': 'scrollback',
          'settings.appearance.copy_on_select': 'copy on select',
          'settings.runtime.shell': 'terminal shell',
          'settings.runtime.shell.cmd': 'CMD',
          'settings.runtime.shell.powershell': 'PowerShell',
          'settings.runtime.shell.wsl': 'WSL',
          'settings.runtime.wsl_distro': 'WSL distro',
          'settings.runtime.wsl_default': 'default distro',
          'settings.runtime.internal_commands': ':ng internal commands',
          'settings.windows.title': 'Windows',
          'settings.shortcuts.arrange': 'arrange shortcut',
          'settings.shortcuts.focus_next': 'focus next shortcut',
          'settings.shortcuts.focus_prev': 'focus prev shortcut',
          'settings.shortcuts.note':
            'Focus each field and press a key combination (Esc resets default).',
          'settings.theme.palette.light_sand': 'Light: Sand',
          'settings.theme.palette.light_sage': 'Light: Sage',
          'settings.theme.palette.light_sky': 'Light: Sky',
          'settings.theme.palette.light_mono': 'Light: Mono',
          'settings.theme.palette.dark_ink': 'Dark: Ink',
          'settings.theme.palette.dark_ocean': 'Dark: Ocean',
          'settings.theme.palette.dark_ember': 'Dark: Ember',
          'settings.theme.palette.dark_mono': 'Dark: Mono',
          'settings.theme.dark': 'dark',
          'settings.theme.light': 'light',
          'settings.font.system_default': 'system default',
          'settings.font.cascadia': 'Cascadia Mono',
          'settings.font.consolas': 'Consolas',
          'settings.font.os_label': 'OS fonts',
          'settings.font.load_os': 'OSからフォントを取得',
          'settings.font.status_idle': 'not loaded',
          'settings.font.status_loading': 'loading...',
          'settings.font.status_loaded': 'OS fonts loaded',
          'settings.font.status_unavailable': 'OS font query not supported',
          'settings.font.status_failed': 'OS font query failed',
          'settings.ai.title': 'AI Coding Agent',
          'settings.ai.tool': 'tool',
          'settings.ai.judge': 'AI terminal state judge',
          'settings.ai.note_tool': 'Selected tool is used to detect agent launch commands.',
          'settings.ai.note_judge_on':
            'When enabled, state detection uses AI notifications and judge results.',
          'settings.ai.note_judge_off': 'When disabled, state detection uses terminal output only.',
          'settings.notifications.title': 'notifications',
          'settings.notifications.toast': 'OS toast',
          'settings.notifications.audio': 'audio',
          'settings.notifications.volume': 'volume',
          'settings.notifications.silence': 'silence (ms)',
          'settings.character.title': 'character',
          'settings.character.watcher': 'terminal character',
          'settings.character.upload': 'upload bundle (.zip)',
          'settings.character.no_upload': 'no upload',
          'settings.character.log_retention': 'log retention (lines)',
          'settings.character.default': 'default',
          'toggle.on': 'ON',
          'toggle.off': 'OFF',
        },
      };

      const FALLBACK_LOCALE = 'ja';
      const localeCandidate = (navigator.language || '').toLowerCase();
      let currentLocale = localeCandidate.startsWith('ja') ? 'ja' : 'en';

      function t(key) {
        if (!key) return '';
        return (
          (I18N_RESOURCES[currentLocale] && I18N_RESOURCES[currentLocale][key]) ||
          (I18N_RESOURCES[FALLBACK_LOCALE] && I18N_RESOURCES[FALLBACK_LOCALE][key]) ||
          key
        );
      }

      function applyI18n() {
        document.querySelectorAll('[data-i18n]').forEach((node) => {
          const key = node.dataset.i18n;
          if (!key) return;
          node.textContent = t(key);
        });
        document.querySelectorAll('[data-i18n-placeholder]').forEach((node) => {
          const key = node.dataset.i18nPlaceholder;
          if (!key) return;
          node.setAttribute('placeholder', t(key));
        });
        document.querySelectorAll('[data-i18n-value]').forEach((node) => {
          const key = node.dataset.i18nValue;
          if (!key) return;
          node.setAttribute('value', t(key));
        });
      }

      const output = document.getElementById('output');
      const input = document.getElementById('chat-input');
      const sendBtn = document.getElementById('send-btn');
      const followToggle = document.querySelector('[data-role="follow-toggle"]');
      const followState = document.getElementById('follow-state');
      const tiles = document.querySelectorAll('[data-role="run-tile"]');
      const phaseLabel = document.querySelector('[data-role="character-phase"]');
      const phaseButtons = document.querySelectorAll('[data-role="phase-button"]');
      const modeChips = document.querySelectorAll('[data-role="mode-chip"]');
      const modeSwitch = document.querySelector('[data-role="mode-switch"]');
      const modeSubtitle = document.querySelector('[data-role="mode-subtitle"]');
      const chatMain = document.querySelector('[data-role="chat-main"]');
      const chatToolbar = document.querySelector('[data-role="chat-toolbar"]');
      const runBoard = document.querySelector('[data-role="run-board"]');
      const settingsBoard = document.querySelector('[data-role="settings-board"]');
      const settingsWindowsCard = document.querySelector('[data-role="settings-windows-card"]');
      const terminalBoard = document.querySelector('[data-role="terminal-board"]');
      const terminalContainer = document.querySelector('[data-role="terminal-container"]');
      const terminalWatcher = document.querySelector('[data-role="terminal-watcher"]');
      const terminalWatcherImage = document.querySelector('[data-role="terminal-watcher-image"]');
      const terminalShell = document.querySelector('.terminal-shell');
      const terminalDebugBadge = document.querySelector('[data-role="terminal-debug-badge"]');
      const terminalDebugSave = document.querySelector('[data-role="terminal-debug-save"]');
      const terminalDebugScreenshot = document.querySelector(
        '[data-role="terminal-debug-screenshot"]'
      );
      const terminalDebugToggle = document.querySelector('[data-role="terminal-debug-toggle"]');

      const notifyToggle = document.querySelector('[data-role="settings-notify-toggle"]');
      const notifyState = document.querySelector('[data-role="settings-notify-state"]');
      const audioToggle = document.querySelector('[data-role="settings-audio-toggle"]');
      const audioState = document.querySelector('[data-role="settings-audio-state"]');
      const volumeSlider = document.querySelector('[data-role="settings-volume"]');
      const silenceInput = document.querySelector('[data-role="settings-silence-timeout"]');
      const llmToggle = document.querySelector('[data-role="settings-llm-toggle"]');
      const llmState = document.querySelector('[data-role="settings-llm-state"]');
      const llmTool = document.querySelector('[data-role="settings-llm-tool"]');
      const codexHookButton = document.querySelector('[data-role="settings-codex-hook"]');
      const codexHookStatus = document.querySelector('[data-role="settings-codex-hook-status"]');
      const characterUpload = document.querySelector('[data-role="settings-character-upload"]');
      const characterUploaded = document.querySelector(
        '[data-role="settings-character-uploaded"]'
      );
      const characterList = document.querySelector('[data-role="settings-character-list"]');
      const characterWatcherToggle = document.querySelector(
        '[data-role="settings-character-watcher"]'
      );
      const characterWatcherState = document.querySelector(
        '[data-role="settings-character-watcher-state"]'
      );
      const terminalTheme = document.querySelector('[data-role="settings-terminal-theme"]');
      const terminalFont = document.querySelector('[data-role="settings-terminal-font"]');
      const terminalFontRefresh = document.querySelector(
        '[data-role="settings-terminal-font-refresh"]'
      );
      const terminalFontStatus = document.querySelector(
        '[data-role="settings-terminal-font-status"]'
      );
      const terminalFontSize = document.querySelector('[data-role="settings-terminal-font-size"]');
      const terminalScrollback = document.querySelector('[data-role="settings-terminal-scrollback"]');
      const terminalShellKind = document.querySelector('[data-role="settings-terminal-shell-kind"]');
      const terminalWslDistroRow = document.querySelector(
        '[data-role="settings-terminal-wsl-distro-row"]'
      );
      const terminalWslDistro = document.querySelector('[data-role="settings-terminal-wsl-distro"]');
      const terminalInternalCommandsToggle = document.querySelector(
        '[data-role="settings-terminal-internal-commands"]'
      );
      const terminalInternalCommandsState = document.querySelector(
        '[data-role="settings-terminal-internal-commands-state"]'
      );
      const keybindArrangeInput = document.querySelector('[data-role="settings-keybind-arrange"]');
      const keybindFocusNextInput = document.querySelector(
        '[data-role="settings-keybind-focus-next"]'
      );
      const keybindFocusPrevInput = document.querySelector(
        '[data-role="settings-keybind-focus-prev"]'
      );
      const terminalCopyToggle = document.querySelector('[data-role="settings-terminal-copy"]');
      const terminalCopyState = document.querySelector('[data-role="settings-terminal-copy-state"]');
      const isWindowsRuntime = /windows/i.test(navigator.userAgent || '');

      applyI18n();

      const baseFontOptions = terminalFont
        ? Array.from(terminalFont.options).map((option) => ({
            value: option.value,
            label: option.textContent || option.value,
          }))
        : [];

      let followEnabled = true;
      let notifyEnabled = true;
      let audioEnabled = true;
      let llmEnabled = false;
      let terminalCopyOnSelect = true;
      let terminalWatcherEnabled = false;
      let watcherReadyNotified = false;
      let wslDistrosLoaded = false;
      let wslDistrosLoading = false;
      const viewParam = new URLSearchParams(window.location.search).get('view');
      const isTerminalView = viewParam === 'terminal';
      const isWatcherView = viewParam === 'watcher';
      const terminalSessionId =
        new URLSearchParams(window.location.search).get('session_id') || `session-${Date.now()}`;
      let terminal;
      let fitAddon;
      let webglAddon;
      let terminalInitialized = false;
      let resizeObserver;
      let resizeDebounceTimer = null;
      let lastResizeCols = null;
      let lastResizeRows = null;
      let focusTransitionToken = null;
      let focusTransitionActive = false;
      let terminalPickupInFlight = false;
      let terminalPickupLastAt = 0;
      const terminalPickupCooldownMs = 120;
      let terminalSurfaceDoubleClickAt = 0;
      const terminalSurfaceDoubleClickCooldownMs = 350;
      let terminalSurfaceSpawnInFlight = false;

      const terminalSettingsDefaults = {
        // Prefer widely-available monospace fonts on Windows first. / Windowsで入手性が高い等幅フォントを優先
        fontFamily:
          "ui-monospace, 'Cascadia Mono', Consolas, 'SFMono-Regular', Menlo, Monaco, 'Liberation Mono', 'DejaVu Sans Mono', monospace",
        fontSize: 18,
        theme: 'dark',
        themePalette: 'dark-ink',
        scrollbackLines: 5000,
        copyOnSelect: true,
      };

      const terminalPerfDefaults = {
        output: {
          maxBufferChars: 2 * 1024 * 1024,
          drain: {
            initialMaxChars: 64 * 1024,
            minChars: 8 * 1024,
            maxCapChars: 128 * 1024,
            maxParts: 64,
          },
        },
        input: {
          controlFlushInitialMs: 8,
          controlFlushMinMs: 8,
          controlFlushMaxMs: 16,
        },
      };

      const themePaletteOptions = Object.freeze({
        light: [
          { value: 'light-sand', i18n: 'settings.theme.palette.light_sand' },
          { value: 'light-sage', i18n: 'settings.theme.palette.light_sage' },
          { value: 'light-sky', i18n: 'settings.theme.palette.light_sky' },
          { value: 'light-mono', i18n: 'settings.theme.palette.light_mono' },
        ],
        dark: [
          { value: 'dark-ink', i18n: 'settings.theme.palette.dark_ink' },
          { value: 'dark-ocean', i18n: 'settings.theme.palette.dark_ocean' },
          { value: 'dark-ember', i18n: 'settings.theme.palette.dark_ember' },
          { value: 'dark-mono', i18n: 'settings.theme.palette.dark_mono' },
        ],
      });

      function stripAnsiText(text) {
        if (!text) return '';
        return String(text)
          .replace(/\x1b\][^\x07]*(\x07|\x1b\\)/g, '')
          .replace(/\x1b\[[0-9;?]*[ -/]*[@-~]/g, '')
          .replace(/\x1b./g, '');
      }

      function fallbackLooksLikeNeedInput(tail) {
        if (!tail) return false;
        const needle = stripAnsiText(tail).toLowerCase();
        return (
          needle.includes('press enter') ||
          needle.includes('press return') ||
          needle.includes('[y/n]') ||
          needle.includes('(y/n)') ||
          needle.includes('continue?') ||
          needle.includes('password:') ||
          needle.includes('are you sure') ||
          /\b(y\/n)\b/i.test(needle)
        );
      }

      function fallbackLooksLikeShellPrompt(tail) {
        if (!tail) return false;
        const cleaned = stripAnsiText(tail);
        const trimmedAll = cleaned.replace(/\s+$/g, '');
        if (!trimmedAll) return false;
        const lines = cleaned.split('\n');
        const last = lines[lines.length - 1] || '';
        const trimmed = last.trim();
        if (trimmed) {
          if (/^PS\s+.+>\s*$/.test(trimmed)) return true;
          if (/^[A-Za-z]:[\\/].*>\s*$/.test(trimmed)) return true;
          if (/^[^@\s]+@[^\s]+:.*[#$]\s*$/.test(trimmed)) return true;
          if (/[^\s][#$]\s*$/.test(trimmed)) return true;
        }
        if (/PS\s+.+>\s*$/.test(trimmedAll)) return true;
        if (/[A-Za-z]:[\\/][^\r\n]*>\s*$/.test(trimmedAll)) return true;
        if (/[^@\s]+@[^\s]+:[^\r\n]*[#$]\s*$/.test(trimmedAll)) return true;
        return false;
      }

      function fallbackComputeState(input) {
        const nowMs = input && typeof input.nowMs === 'number' ? input.nowMs : Date.now();
        const lastOutputAtMs =
          input && typeof input.lastOutputAtMs === 'number' ? input.lastOutputAtMs : nowMs;
        const lastTail = (input && input.lastTail) || '';
        const exitCode =
          input && Object.prototype.hasOwnProperty.call(input, 'exitCode') ? input.exitCode : null;
        const commandActive =
          input && Object.prototype.hasOwnProperty.call(input, 'commandActive')
            ? Boolean(input.commandActive)
            : true;

        if (exitCode !== null && exitCode !== undefined) {
          if (exitCode === 0) {
            return { state: TerminalObservation.success, reason: 'exit 0', idleMs: 0 };
          }
          return { state: TerminalObservation.fail, reason: 'exit non-zero', idleMs: 0 };
        }

        const idleMs = Math.max(0, nowMs - lastOutputAtMs);
        if (fallbackLooksLikeNeedInput(lastTail)) {
          return { state: TerminalObservation.needInput, reason: 'prompt-like tail', idleMs };
        }
        if (!commandActive) {
          return { state: TerminalObservation.idle, reason: 'idle', idleMs };
        }
        if (fallbackLooksLikeShellPrompt(lastTail)) {
          return { state: TerminalObservation.success, reason: 'shell prompt', idleMs };
        }
        return { state: TerminalObservation.running, reason: 'running', idleMs };
      }

      const fallbackTerminalObserver = {
        ObservationState: {
          idle: 'idle',
          running: 'running',
          needInput: 'need-input',
          success: 'success',
          fail: 'fail',
        },
        TerminalStateDetector: {
          computeState: fallbackComputeState,
          tailForObservation: (text, maxChars) => {
            if (!text) return '';
            const limit = typeof maxChars === 'number' ? maxChars : 400;
            const normalized = String(text).replace(/\r\n/g, '\n');
            return normalized.slice(Math.max(0, normalized.length - limit));
          },
          looksLikeNeedInput: fallbackLooksLikeNeedInput,
          looksLikeShellPrompt: fallbackLooksLikeShellPrompt,
        },
      };

      const terminalObserver = window.TerminalObserver || /** @type {any} */ (fallbackTerminalObserver);
      const TerminalObservation = Object.freeze({
        idle: 'idle',
        running: 'running',
        needInput: 'need-input',
        success: 'success',
        fail: 'fail',
        ...(terminalObserver.ObservationState || {}),
      });
      const JUDGE_TAIL_MAX_CHARS = 1500;
      const JUDGE_TAIL_MAX_LINES = 50;
      const DEFAULT_IDLE_TIMEOUT_MS = 30000;
      const terminalStateDetector =
        terminalObserver.TerminalStateDetector || terminalObserver || /** @type {any} */ ({});
      const agentObserver = window.AgentEventObserver || /** @type {any} */ ({});
      const stateIntegrator =
        window.StateIntegrator ||
        Object.freeze({
          merge: (terminal, agent) => {
            if (agent && agent.state) {
              return { state: agent.state, reason: agent.reason || 'agent' };
            }
            if (terminal && terminal.state) {
              return { state: terminal.state, reason: terminal.reason || 'terminal' };
            }
            return { state: TerminalObservation.idle, reason: 'default' };
          },
          mergeWithGuard: (previous, terminal, agent) => {
            const merged =
              agent && agent.state
                ? { state: agent.state, reason: agent.reason || 'agent' }
                : terminal && terminal.state
                ? { state: terminal.state, reason: terminal.reason || 'terminal' }
                : { state: TerminalObservation.idle, reason: 'default' };
            if (
              previous &&
              merged.state === TerminalObservation.needInput &&
              previous.state !== TerminalObservation.running &&
              previous.state !== TerminalObservation.needInput
            ) {
              return {
                next: {
                  state: TerminalObservation.running,
                  reason: 'guard running-before-need-input',
                },
                guarded: true,
              };
            }
            return { next: merged, guarded: false };
          },
        });

      let terminalObserved = { state: TerminalObservation.idle, reason: 'init' };
      let terminalStickyObserved = { state: TerminalObservation.idle, reason: 'idle' };
      let agentObserved = null;
      let mergedObserved = { state: TerminalObservation.idle, reason: 'init' };
      let latchedObserved = null;
      let lastReportedObservationState = null;
      let terminalLastOutputAt = Date.now();
      let terminalLastActivityAt = Date.now();
      let terminalLastChunkTail = '';
      let terminalExitCode = null;
      let outputTailBuffer = '';
      let idleJudgeTimer = null;
      let judgeInFlight = false;
      let lastJudgeAtMs = 0;
      let lastJudgeReason = '';
      let agentSessionActive = false;
      let agentSessionSource = null;
      let terminalCommandActive = false;
      let terminalHasUserCommand = false;
      let needInputGuardQueued = false;
      let inputLineBuffer = '';
      let inputSawCarriage = false;
      let lastTerminalEvent = { type: 'init', detail: '' };
      let lastInputLine = '';
      let inputCaptureMode = 'auto';
      const captureInputLinesFromSendQueue = true;
      let keyInputBuffer = '';
      let skipNextCarriage = false;
      let lastKeyLabel = '';
      const inputChunkHistory = [];
      const INPUT_CHUNK_HISTORY_LIMIT = 10;
      let dataInputSeenAt = 0;
      let dataInputLineActive = false;
      const nagomiInternalCaptureModes = Object.freeze({
        unknown: 'unknown',
        passThrough: 'pass-through',
        suppressCandidate: 'suppress-candidate',
      });
      const nagomiInternalCapture = {
        mode: nagomiInternalCaptureModes.unknown,
        pending: '',
        skipNextLf: false,
        echoedDisplay: '',
      };
      let nagomiInternalEnabled = true;

      function truncateDebugText(value, limit = 48) {
        if (!value) return '';
        const text = String(value);
        if (text.length <= limit) return text;
        return `${text.slice(0, limit)}…`;
      }

      function setLastTerminalEvent(type, detail) {
        lastTerminalEvent = { type: type || 'event', detail: detail || '' };
        updateTerminalDebugBadge();
      }

      function updateTerminalDebugBadge() {
        if (!terminalDebugBadge) return;
        const toolName = normalizeToolName(settingsState.llm_tool || 'codex') || '-';
        const stateLabel = mergedObserved && mergedObserved.state ? mergedObserved.state : 'idle';
        const eventType = lastTerminalEvent.type || '-';
        const eventDetail = truncateDebugText(lastTerminalEvent.detail || '');
        const linePreview = truncateDebugText(lastInputLine || '');
        const keyPreview = truncateDebugText(lastKeyLabel || '');
        const lastChunk =
          inputChunkHistory.length > 0
            ? truncateDebugText(inputChunkHistory[inputChunkHistory.length - 1].preview || '')
            : '';
        terminalDebugBadge.textContent = `state=${stateLabel} | agent=${agentSessionActive ? 'on' : 'off'} | tool=${toolName} | cap=${inputCaptureMode} | data=${dataInputLineActive ? 'on' : 'off'} | buf=${inputLineBuffer.length}/${keyInputBuffer.length} | key=${keyPreview} | chunk=${lastChunk} | event=${eventType} ${eventDetail} | line=${linePreview}`;
      }

      function applyTerminalWatcherVisibility() {
        if (!terminalWatcher) return;
        terminalWatcher.style.display = isWatcherView ? 'block' : 'none';
      }

      function reportTerminalObservation(state) {
        if (!isTerminalView) return;
        if (!state) return;
        if (state === lastReportedObservationState) return;
        lastReportedObservationState = state;
        invokeWithSession('report_terminal_observation', {
          sessionId: terminalSessionId,
          state,
        }).catch(() => {});
      }

        function setTerminalStickyObserved(state, reason) {
          const nextState = state || TerminalObservation.idle;
          terminalStickyObserved = { state: nextState, reason: reason || nextState || 'idle' };
        }

        function isFinalObservedState(state) {
          return (
            state === TerminalObservation.needInput ||
            state === TerminalObservation.success ||
            state === TerminalObservation.fail
          );
        }

        function latchObservedState(next) {
          if (!next || !next.state) return;
          if (!isFinalObservedState(next.state)) return;
          if (
            latchedObserved &&
            latchedObserved.state === next.state &&
            latchedObserved.reason === (next.reason || next.state)
          ) {
            return;
          }
          latchedObserved = { state: next.state, reason: next.reason || next.state };
        }

        function clearLatchedObserved() {
          if (!latchedObserved) return;
          latchedObserved = null;
        }

        function resetTerminalToIdle(reason) {
          terminalCommandActive = false;
          setTerminalStickyObserved(TerminalObservation.idle, reason || 'idle');
        }

        function startTerminalCommand(reason) {
          terminalCommandActive = true;
          terminalHasUserCommand = true;
          terminalLastActivityAt = Date.now();
          terminalLastOutputAt = terminalLastActivityAt;
          terminalLastChunkTail = '';
          resetAgentOutputTail();
          clearLatchedObserved();
          setLastTerminalEvent('command', reason || 'command');
          updateTerminalObservedState();
        }

      function finishTerminalCommand(state, reason) {
        terminalCommandActive = false;
        setTerminalStickyObserved(state, reason || state);
      }

      async function appendDebugSnapshot() {
        if (!terminalDebugSave) return;
        const payload = {
          session_id: terminalSessionId || null,
          state: mergedObserved ? mergedObserved.state : null,
          agent_active: agentSessionActive,
          tool: normalizeToolName(settingsState.llm_tool || 'codex') || null,
          capture: inputCaptureMode,
          buffer_data_len: inputLineBuffer.length,
          buffer_key_len: keyInputBuffer.length,
          buffer_data: truncateDebugText(inputLineBuffer || '', 120),
          buffer_key: truncateDebugText(keyInputBuffer || '', 120),
          last_key: lastKeyLabel || '',
          input_chunks: inputChunkHistory.slice(-INPUT_CHUNK_HISTORY_LIMIT),
          line: lastInputLine,
          event_type: lastTerminalEvent.type,
          event_detail: lastTerminalEvent.detail,
          badge: terminalDebugBadge ? terminalDebugBadge.textContent : '',
        };
        const originalLabel = terminalDebugSave.textContent;
        terminalDebugSave.textContent = t('debug.status.saving');
        try {
          await invokeWithSession('append_terminal_debug_snapshot', { payload });
          terminalDebugSave.textContent = t('debug.status.saved');
          setTimeout(() => {
            if (terminalDebugSave) terminalDebugSave.textContent = originalLabel;
          }, 900);
        } catch {
          terminalDebugSave.textContent = t('debug.status.failed');
          setTimeout(() => {
            if (terminalDebugSave) terminalDebugSave.textContent = originalLabel;
          }, 1200);
        }
      }

      async function saveDebugScreenshot() {
        if (!terminalDebugScreenshot) return;
        const originalLabel = terminalDebugScreenshot.textContent;
        terminalDebugScreenshot.textContent = t('debug.status.saving');
        try {
          const path = await invokeWithSession('save_debug_screenshot', {});
          if (path) {
            console.debug('[terminal-debug] screenshot saved', { path });
          }
          terminalDebugScreenshot.textContent = t('debug.status.saved');
          setTimeout(() => {
            if (terminalDebugScreenshot) terminalDebugScreenshot.textContent = originalLabel;
          }, 1200);
        } catch {
          terminalDebugScreenshot.textContent = t('debug.status.failed');
          setTimeout(() => {
            if (terminalDebugScreenshot) terminalDebugScreenshot.textContent = originalLabel;
          }, 1400);
        }
      }

      function terminalWatcherFaceForState(state) {
        if (terminalObserver.assetPathForState) return terminalObserver.assetPathForState(state);
        switch (state) {
          case TerminalObservation.success:
            return 'assets/watcher/nagomisan_full_idle.png';
          case TerminalObservation.fail:
            return 'assets/watcher/nagomisan_full_fail.png';
          case TerminalObservation.needInput:
            return 'assets/watcher/nagomisan_full_need-input.png';
          case TerminalObservation.running:
            return 'assets/watcher/nagomisan_full_running.png';
          case TerminalObservation.idle:
            return 'assets/watcher/nagomisan_full_idle.png';
          default:
            return 'assets/watcher/nagomisan_full_idle.png';
        }
      }

      function applyTerminalObservedState(state, title) {
        if (terminalWatcherImage) {
          terminalWatcherImage.src = terminalWatcherFaceForState(state);
        }
        if (terminalWatcher) {
          terminalWatcher.title = title || state;
        }
        const shell =
          (terminalWatcher && terminalWatcher.parentElement) ||
          (terminalContainer && terminalContainer.parentElement);
        if (shell && shell.classList) {
          shell.classList.remove(
            'state-running',
            'state-need-input',
            'state-success',
            'state-fail'
          );
          let appliedState = null;
          if (state === TerminalObservation.needInput) {
            appliedState = 'need-input';
          } else if (state === TerminalObservation.fail) {
            appliedState = 'fail';
          } else if (state === TerminalObservation.running) {
            appliedState = 'running';
          }
          if (appliedState) {
            shell.classList.add(`state-${appliedState}`);
          }
        }
        updateTerminalDebugBadge();
      }

        function updateMergedObservedState(title) {
          let nextObserved = null;
          let guardApplied = false;
          if (stateIntegrator && typeof stateIntegrator.mergeWithGuard === 'function') {
            const mergedWithGuard = stateIntegrator.mergeWithGuard(
              mergedObserved,
              terminalObserved,
              agentObserved
            );
            nextObserved = mergedWithGuard && mergedWithGuard.next ? mergedWithGuard.next : null;
            guardApplied = Boolean(mergedWithGuard && mergedWithGuard.guarded);
          } else if (stateIntegrator && typeof stateIntegrator.merge === 'function') {
            nextObserved = stateIntegrator.merge(terminalObserved, agentObserved);
          } else if (terminalObserved && terminalObserved.state) {
            nextObserved = { state: terminalObserved.state, reason: terminalObserved.reason };
          } else {
            nextObserved = { state: TerminalObservation.idle, reason: 'default' };
          }
          if (nextObserved && nextObserved.state === TerminalObservation.running) {
            clearLatchedObserved();
          }
          latchObservedState(nextObserved);
          mergedObserved = latchedObserved || nextObserved;
          reportTerminalObservation(mergedObserved.state);
          const nextTitle = title || mergedObserved.reason || mergedObserved.state;
          applyTerminalObservedState(mergedObserved.state, nextTitle);
          if (guardApplied && !needInputGuardQueued) {
            needInputGuardQueued = true;
            Promise.resolve().then(() => {
              needInputGuardQueued = false;
              updateMergedObservedState('guard running-before-need-input');
            });
          }
        }

      function updateTerminalObservedState() {
        if (!terminalHasUserCommand) {
          terminalObserved = { state: terminalStickyObserved.state, reason: terminalStickyObserved.reason };
          updateMergedObservedState(agentObserved ? null : terminalObserved.reason);
          return;
        }
        if (!terminalStateDetector || typeof terminalStateDetector.computeState !== 'function') {
          terminalObserved = { state: terminalStickyObserved.state, reason: terminalStickyObserved.reason };
          updateMergedObservedState(agentObserved ? null : terminalObserved.reason);
          return;
        }
        if (terminalExitCode !== null && terminalExitCode !== undefined) {
          terminalCommandActive = false;
          const exitState =
            terminalExitCode === 0 ? TerminalObservation.success : TerminalObservation.fail;
          terminalObserved = { state: exitState, reason: `exit ${terminalExitCode}` };
          setTerminalStickyObserved(exitState, terminalObserved.reason);
          updateMergedObservedState(agentObserved ? null : terminalObserved.reason);
          return;
        }

        if (!terminalCommandActive) {
          terminalObserved = { state: terminalStickyObserved.state, reason: terminalStickyObserved.reason };
          updateMergedObservedState(agentObserved ? null : terminalObserved.reason);
          return;
        }

        const result = terminalStateDetector.computeState({
          nowMs: Date.now(),
          lastOutputAtMs: terminalLastOutputAt,
          lastTail: terminalLastChunkTail,
          exitCode: terminalExitCode,
          commandActive: terminalCommandActive,
        });
        terminalObserved = { state: result.state, reason: result.reason };
        if (
          terminalCommandActive &&
          (result.state === TerminalObservation.success || result.state === TerminalObservation.fail)
        ) {
          finishTerminalCommand(result.state, result.reason);
        }
        updateMergedObservedState(agentObserved ? null : result.reason);
      }

      function setAgentObservedState(next) {
        agentObserved = next;
        updateMergedObservedState(next && next.reason);
      }

      function clearAgentObservedState(reason) {
        if (!agentObserved) return;
        agentObserved = null;
        updateMergedObservedState(reason || 'terminal');
      }

      function applyAgentObservationFromHook(payload) {
        if (!payload || !payload.judge_state) return null;
        if (!agentObserver || typeof agentObserver.observeHookPayload !== 'function') return null;
        const observed = agentObserver.observeHookPayload(payload);
        if (!observed) return null;
        setAgentObservedState(observed);
        return observed;
      }

      function normalizeToolName(value) {
        if (!value) return '';
        const trimmed = String(value).trim();
        if (!trimmed) return '';
        const parts = trimmed.split(/[/\\]/);
        const last = parts[parts.length - 1] || '';
        return last.replace(/\.(exe|cmd|ps1)$/i, '').toLowerCase();
      }

      function isToolCommand(line, toolName) {
        const trimmed = String(line || '').trim();
        if (!trimmed) return false;
        const head = trimmed.split(/\s+/)[0] || '';
        return normalizeToolName(head) === toolName;
      }

        function markAgentRunning(reason) {
          agentSessionActive = true;
          terminalHasUserCommand = true;
          if (!agentSessionSource) {
            agentSessionSource = normalizeToolName(settingsState.llm_tool || 'codex');
          }
          clearLatchedObserved();
          setAgentObservedState({ state: TerminalObservation.running, reason: reason || 'agent' });
          setLastTerminalEvent('input', reason || 'agent');
          terminalLastActivityAt = Date.now();
          scheduleIdleJudge('agent-input');
        }

        function resetAgentSession(reason) {
          agentSessionActive = false;
          agentSessionSource = null;
          agentObserved = null;
          if (idleJudgeTimer) {
            clearTimeout(idleJudgeTimer);
            idleJudgeTimer = null;
          }
          resetTerminalToIdle(reason || 'agent quit');
          clearLatchedObserved();
          updateTerminalObservedState();
        }

      function resetAgentOutputTail() {
        outputTailBuffer = '';
      }

      function appendOutputTail(chunk) {
        if (!chunk) return;
        const normalized = String(chunk).replace(/\r\n/g, '\n');
        outputTailBuffer += normalized;
        if (outputTailBuffer.length > JUDGE_TAIL_MAX_CHARS) {
          outputTailBuffer = outputTailBuffer.slice(
            Math.max(0, outputTailBuffer.length - JUDGE_TAIL_MAX_CHARS)
          );
        }
      }

      function emitLocalTerminalOutput(chunk, reason) {
        if (!chunk) return;
        const now = Date.now();
        terminalLastOutputAt = now;
        terminalLastActivityAt = now;
        appendOutputTail(chunk);
        if (terminalStateDetector.tailForObservation) {
          terminalLastChunkTail = terminalStateDetector.tailForObservation(outputTailBuffer);
        } else {
          terminalLastChunkTail = outputTailBuffer || String(chunk);
        }
        scheduleIdleJudge(reason || 'local-output');
        updateTerminalObservedState();
        enqueueTerminalOutput(chunk);
        forceDrainOutputNow();
      }

      function buildJudgeTail() {
        if (!outputTailBuffer) return '';
        const lines = outputTailBuffer.split('\n');
        if (lines.length <= JUDGE_TAIL_MAX_LINES) {
          return lines.join('\n');
        }
        return lines.slice(-JUDGE_TAIL_MAX_LINES).join('\n');
      }

      function getIdleTimeoutMs() {
        const value = Number(settingsState && settingsState.silence_timeout_ms);
        if (!Number.isFinite(value) || value <= 0) {
          return DEFAULT_IDLE_TIMEOUT_MS;
        }
        return value;
      }

      function scheduleIdleJudge(reason) {
        if (idleJudgeTimer) {
          clearTimeout(idleJudgeTimer);
        }
        const timeoutMs = getIdleTimeoutMs();
        idleJudgeTimer = setTimeout(() => {
          idleJudgeTimer = null;
          if (!agentSessionActive) return;
          if (terminalExitCode !== null && terminalExitCode !== undefined) return;
          const idleMs = Date.now() - terminalLastActivityAt;
          if (idleMs < timeoutMs - 20) return;
          triggerJudge(reason || 'idle', null);
        }, timeoutMs);
      }

      function normalizeJudgeState(value) {
        const raw = String(value || '').trim().toLowerCase();
        if (raw === 'success') return TerminalObservation.success;
        if (raw === 'failure' || raw === 'fail' || raw === 'error') return TerminalObservation.fail;
        if (raw === 'need_input' || raw === 'need-input' || raw === 'waiting_input') {
          return TerminalObservation.needInput;
        }
        return null;
      }

      function applyJudgeResult(result, reason) {
        if (!result) return;
        const normalized = normalizeJudgeState(result.state);
        if (!normalized) return;
        const summary = result.summary || '';
        const title = summary || reason || 'judge';
        setAgentObservedState({ state: normalized, reason: title });
        if (!isTerminalView) {
          if (normalized === TerminalObservation.success) setCharacterPhase('success');
          if (normalized === TerminalObservation.fail) setCharacterPhase('error');
          if (normalized === TerminalObservation.needInput) setCharacterPhase('need_input');
        }
      }

      function applyFallbackJudge(reason, hookKind) {
        if (hookKind === 'error') {
          setAgentObservedState({ state: TerminalObservation.fail, reason: reason || 'hook error' });
          if (!isTerminalView) setCharacterPhase('error');
          return;
        }
        if (hookKind === 'completed') {
          setAgentObservedState({
            state: TerminalObservation.success,
            reason: reason || 'hook completed',
          });
          if (!isTerminalView) setCharacterPhase('success');
          return;
        }
        if (hookKind === 'need_input') {
          setAgentObservedState({
            state: TerminalObservation.needInput,
            reason: reason || 'hook need_input',
          });
          if (!isTerminalView) setCharacterPhase('need_input');
          return;
        }
        setAgentObservedState({ state: TerminalObservation.needInput, reason: reason || 'idle' });
        if (!isTerminalView) setCharacterPhase('need_input');
      }

      async function triggerJudge(reason, hookKind) {
        if (!agentSessionActive) return;
        if (terminalExitCode !== null && terminalExitCode !== undefined) return;
        const now = Date.now();
        if (judgeInFlight) return;
        if (now - lastJudgeAtMs < 800) return;
        lastJudgeAtMs = now;
        lastJudgeReason = reason || '';

        if (!llmEnabled) {
          applyFallbackJudge(reason, hookKind);
          return;
        }

        judgeInFlight = true;
        try {
          const tail = buildJudgeTail();
          const result = await invokeWithSession('tool_judge', {
            tool: settingsState.llm_tool || 'codex',
            tail,
          });
          applyJudgeResult(result, reason);
        } catch {
          applyFallbackJudge(reason, hookKind);
        } finally {
          judgeInFlight = false;
        }
      }

      function handleHookEvent(payload) {
        if (!payload) return null;
        const hasSessionId = Boolean(payload.source_session_id);
        if (hasSessionId && payload.source_session_id !== terminalSessionId) return null;
        if (!hasSessionId && !agentSessionActive) return null;
        setLastTerminalEvent('hook', payload.kind || payload.judge_state || 'unknown');
        if (payload.source && !agentSessionSource) {
          agentSessionSource = payload.source;
        }
        if (!agentSessionActive) {
          agentSessionActive = true;
        }
        const observed = applyAgentObservationFromHook(payload);
        if (observed) return observed;
        const hookKind = payload.kind || null;
        if (llmEnabled) {
          triggerJudge('hook', hookKind);
          return null;
        }
        applyFallbackJudge('hook', hookKind);
        return null;
      }

      function stripAnsiControlSequences(text) {
        const input = String(text || '');
        let out = '';
        let i = 0;
        while (i < input.length) {
          const ch = input[i];
          if (ch === '\x1b') {
            i += 1;
            if (i >= input.length) break;
            const next = input[i];
            if (next === '[') {
              i += 1;
              while (i < input.length) {
                const code = input.charCodeAt(i);
                i += 1;
                if (code >= 0x40 && code <= 0x7e) break;
              }
              continue;
            }
            if (next === ']') {
              i += 1;
              while (i < input.length) {
                if (input[i] === '\x07') {
                  i += 1;
                  break;
                }
                if (input[i] === '\x1b' && i + 1 < input.length && input[i + 1] === '\\') {
                  i += 2;
                  break;
                }
                i += 1;
              }
              continue;
            }
            i += 1;
            continue;
          }
          if (ch < ' ' && ch !== '\r' && ch !== '\n' && ch !== '\t') {
            i += 1;
            continue;
          }
          if (ch === '\x7f') {
            i += 1;
            continue;
          }
          out += ch;
          i += 1;
        }
        return out;
      }

      function parseNagomiInternalCommand(line) {
        const cleaned = stripAnsiControlSequences(String(line || ''));
        const trimmed = cleaned.trim();
        if (!trimmed.startsWith(':ng')) return null;
        const rest = trimmed.slice(3);
        const body = rest.trim();
        if (!body) return { kind: 'usage', name: '', args: [], rawArgs: '' };
        if (rest && !/^\s/.test(rest)) {
          return { kind: 'unknown', name: '', args: [], rawArgs: body };
        }
        const parts = body.split(/\s+/).filter(Boolean);
        if (!parts.length) return { kind: 'usage', name: '', args: [], rawArgs: '' };
        return {
          kind: 'command',
          name: String(parts[0] || '').toLowerCase(),
          args: parts.slice(1),
          rawArgs: body,
        };
      }

      function nagomiInternalDisplayText(line) {
        const cleaned = stripAnsiControlSequences(String(line || ''));
        if (cleaned.trimStart().startsWith(':')) return cleaned;
        return null;
      }

      function appendNagomiLocalEchoDelta(capture, nextText) {
        const previous = Array.from(String(capture.echoedDisplay || ''));
        const next = String(nextText || '');
        const nextChars = Array.from(next);
        let common = 0;
        while (
          common < previous.length &&
          common < nextChars.length &&
          previous[common] === nextChars[common]
        ) {
          common += 1;
        }
        let out = '';
        for (let i = common; i < previous.length; i += 1) {
          out += '\b \b';
        }
        for (let i = common; i < nextChars.length; i += 1) {
          out += nextChars[i];
        }
        capture.echoedDisplay = next;
        return out;
      }

      function executeNagomiInternalCommand(command) {
        if (!command) return '';
        if (command.kind === 'usage') {
          return '[nagomi] usage: :ng ping\r\n';
        }
        if (command.kind === 'command' && command.name === 'ping' && command.args.length === 0) {
          return 'pong\r\n';
        }
        const rawArgs =
          command.rawArgs ||
          [command.name, ...(Array.isArray(command.args) ? command.args : [])]
            .filter(Boolean)
            .join(' ')
            .trim();
        return `[nagomi] unknown :ng command: ${rawArgs}\r\n`;
      }

      function processNagomiInternalInputChunk(chunk) {
        const capture = nagomiInternalCapture;
        const source = String(chunk || '');
        let forwardText = '';
        const internalCommands = [];
        let localEchoText = '';
        for (let i = 0; i < source.length; i += 1) {
          const ch = source[i];
          if (capture.skipNextLf) {
            capture.skipNextLf = false;
            if (ch === '\n') continue;
          }
          if (ch === '\r' || ch === '\n') {
            const command = parseNagomiInternalCommand(capture.pending);
            if (command) {
              const displayLine = stripAnsiControlSequences(capture.pending).trim();
              if (!capture.echoedDisplay) {
                localEchoText += appendNagomiLocalEchoDelta(
                  capture,
                  nagomiInternalDisplayText(capture.pending)
                );
              }
              localEchoText += '\r\n';
              internalCommands.push({ command, line: displayLine });
              if (ch === '\r') {
                capture.skipNextLf = true;
              }
            } else {
              forwardText += capture.pending;
              forwardText += ch;
            }
            capture.pending = '';
            capture.mode = nagomiInternalCaptureModes.unknown;
            capture.echoedDisplay = '';
            continue;
          }

          if (capture.mode === nagomiInternalCaptureModes.passThrough) {
            forwardText += ch;
            continue;
          }

          if (ch === '\x08' || ch === '\x7f') {
            if (capture.pending.length > 0) {
              capture.pending = capture.pending.slice(0, -1);
            }
            if (capture.mode === nagomiInternalCaptureModes.suppressCandidate) {
              localEchoText += appendNagomiLocalEchoDelta(
                capture,
                nagomiInternalDisplayText(capture.pending)
              );
            }
            continue;
          }

          capture.pending += ch;
          if (capture.mode === nagomiInternalCaptureModes.unknown) {
            const cleaned = stripAnsiControlSequences(capture.pending);
            const firstNonWhitespace = cleaned.match(/\S/);
            if (firstNonWhitespace && firstNonWhitespace[0] === ':') {
              capture.mode = nagomiInternalCaptureModes.suppressCandidate;
            } else if (firstNonWhitespace && firstNonWhitespace[0]) {
              capture.mode = nagomiInternalCaptureModes.passThrough;
              forwardText += capture.pending;
              capture.pending = '';
            }
          }
          if (capture.mode === nagomiInternalCaptureModes.suppressCandidate) {
            localEchoText += appendNagomiLocalEchoDelta(
              capture,
              nagomiInternalDisplayText(capture.pending)
            );
          }
        }
        return { forwardText, internalCommands, localEchoText };
      }

      function resetNagomiInternalCapture() {
        nagomiInternalCapture.mode = nagomiInternalCaptureModes.unknown;
        nagomiInternalCapture.pending = '';
        nagomiInternalCapture.skipNextLf = false;
        nagomiInternalCapture.echoedDisplay = '';
      }

      function rollbackNagomiInternalCommands(reason, error) {
        if (!nagomiInternalEnabled) return;
        nagomiInternalEnabled = false;
        settingsState.terminal_internal_commands_enabled = false;
        resetNagomiInternalCapture();
        if (terminalInternalCommandsState) {
          setToggleState(false, terminalInternalCommandsState);
        }
        const message = reason || 'rollback';
        setLastTerminalEvent('internal-rollback', message);
        debugTerminal('internal-rollback', {
          reason: message,
          error: error ? String(error) : '',
        });
        saveSettingsToBackend();
      }

      function handleTerminalLine(line) {
        const toolName = normalizeToolName(settingsState.llm_tool || 'codex');
        const trimmed = String(line || '').trim();
        const internal = parseNagomiInternalCommand(trimmed);
        lastInputLine = trimmed;
        updateTerminalDebugBadge();
        if (nagomiInternalEnabled && internal) {
          const internalEvent =
            internal.kind === 'usage' ? 'usage' : internal.name || internal.rawArgs || 'unknown';
          setLastTerminalEvent('internal', internalEvent);
          return;
        }
        if (agentSessionActive && toolName && trimmed && isToolCommand(trimmed, toolName)) {
          setLastTerminalEvent('tool', 'start');
          updateTerminalObservedState();
          return;
        }
        if (agentSessionActive) {
          if (trimmed.toLowerCase() === '/quit') {
            setLastTerminalEvent('agent', 'quit');
            resetAgentSession('agent quit');
            return;
          }
          if (trimmed) {
            terminalHasUserCommand = true;
          }
          resetAgentOutputTail();
          markAgentRunning(trimmed ? 'agent input' : 'agent enter');
          return;
        }
        if (toolName && trimmed && isToolCommand(trimmed, toolName)) {
          terminalHasUserCommand = true;
          agentSessionActive = true;
          agentSessionSource = toolName;
          resetAgentOutputTail();
          setLastTerminalEvent('tool', 'start');
          updateTerminalObservedState();
          return;
        }
        if (!trimmed) return;
        terminalHasUserCommand = true;
        const reason = terminalCommandActive ? 'command input' : 'command start';
        startTerminalCommand(reason);
      }

      function ingestInputLines(text) {
        if (!text) return;
        if (inputCaptureMode === 'textarea') return;
        terminalLastActivityAt = Date.now();
        const dataFresh = Date.now() - dataInputSeenAt < 1000;
        if (dataFresh && keyInputBuffer) {
          keyInputBuffer = '';
        }
        for (let i = 0; i < text.length; i += 1) {
          const ch = text[i];
          if (ch === '\x1b') {
            const next = text[i + 1];
            if (next === '[') {
              let j = i + 2;
              while (j < text.length) {
                const code = text.charCodeAt(j);
                if (code >= 0x40 && code <= 0x7e) {
                  j += 1;
                  break;
                }
                j += 1;
              }
              i = j - 1;
              continue;
            }
            if (next) {
              i += 1;
            }
            continue;
          }
          if (ch === '\r') {
            if (skipNextCarriage) {
              skipNextCarriage = false;
              inputSawCarriage = true;
              continue;
            }
            const candidate = inputLineBuffer || keyInputBuffer;
            handleTerminalLine(candidate);
            keyInputBuffer = '';
            inputLineBuffer = '';
            dataInputLineActive = false;
            inputSawCarriage = true;
            continue;
          }
          if (ch === '\n') {
            if (inputSawCarriage) {
              inputSawCarriage = false;
              continue;
            }
            const candidate = inputLineBuffer || keyInputBuffer;
            handleTerminalLine(candidate);
            keyInputBuffer = '';
            inputLineBuffer = '';
            dataInputLineActive = false;
            continue;
          }
          if (ch === '\x7f' || ch === '\b') {
            if (inputLineBuffer.length > 0) {
              inputLineBuffer = inputLineBuffer.slice(0, -1);
            }
            dataInputLineActive = inputLineBuffer.length > 0;
            continue;
          }
          inputSawCarriage = false;
          if (inputCaptureMode !== 'textarea' && isPrintableInputChar(ch)) {
            inputCaptureMode = 'data';
          }
          if (isPrintableInputChar(ch)) {
            inputLineBuffer += ch;
            dataInputLineActive = true;
          }
        }
      }

      function setCharacterPhase(phase) {
        if (!phaseLabel) return;
        phaseLabel.textContent = phase;
      }
      let rawInputQueue = '';
      let rafScheduled = false;
      let controlFlushTimer = null;
      let controlInputFlushMs = terminalPerfDefaults.input.controlFlushInitialMs;
      const CONTROL_INPUT_FLUSH_MIN = terminalPerfDefaults.input.controlFlushMinMs;
      const CONTROL_INPUT_FLUSH_MAX = terminalPerfDefaults.input.controlFlushMaxMs;
      let pendingEcho = '';
      let pendingEchoTimer = null;
      let suppressEchoActive = true;
      // Send queue for single-flight invoke / 送信キューで invoke を単発化
      let sendQueue = '';
      let sendInFlight = false;
      let sendRetryTimer = null;
      let sendRetryCount = 0;
      let terminalSessionReady = false;
      const SEND_RETRY_DELAY_MS = 80;
      const SEND_RETRY_MAX = 40;
      // Output buffer to coalesce writes / 出力を合体して write 回数を削減
      const outputChunks = [];
      let outputHead = 0;
      let outputBytes = 0;
      let outputScheduled = false;
      let outputWriting = false;
      const MAX_TERMINAL_OUTPUT_BUFFER = terminalPerfDefaults.output.maxBufferChars;
      let terminalOutputDrainMax = terminalPerfDefaults.output.drain.initialMaxChars;
      const TERMINAL_OUTPUT_DRAIN_MIN = terminalPerfDefaults.output.drain.minChars;
      const TERMINAL_OUTPUT_DRAIN_MAX_CAP = terminalPerfDefaults.output.drain.maxCapChars;
      const TERMINAL_OUTPUT_DRAIN_MAX_PARTS = terminalPerfDefaults.output.drain.maxParts;
      let terminalOutputLastWriteMs = 0;
      const MAX_PENDING_ECHO = 256;
      const PENDING_ECHO_TTL_MS = 1000;
      const terminalKeybindDefaults = Object.freeze({
        arrange: 'Ctrl+Shift+Y',
        focusNext: 'Ctrl+Shift+J',
        focusPrev: 'Ctrl+Shift+K',
      });

      function normalizeShortcutKeyToken(raw) {
        const text = String(raw || '').trim();
        if (!text) return '';
        const lower = text.toLowerCase();
        if (
          lower === 'control' ||
          lower === 'ctrl' ||
          lower === 'shift' ||
          lower === 'alt' ||
          lower === 'meta'
        ) {
          return '';
        }
        const keyAliases = {
          esc: 'Escape',
          escape: 'Escape',
          enter: 'Enter',
          return: 'Enter',
          tab: 'Tab',
          space: 'Space',
          spacebar: 'Space',
          backspace: 'Backspace',
          delete: 'Delete',
          insert: 'Insert',
          home: 'Home',
          end: 'End',
          pageup: 'PageUp',
          pagedown: 'PageDown',
          up: 'ArrowUp',
          down: 'ArrowDown',
          left: 'ArrowLeft',
          right: 'ArrowRight',
          arrowup: 'ArrowUp',
          arrowdown: 'ArrowDown',
          arrowleft: 'ArrowLeft',
          arrowright: 'ArrowRight',
        };
        if (keyAliases[lower]) {
          return keyAliases[lower];
        }
        if (/^f\d{1,2}$/i.test(text)) {
          return text.toUpperCase();
        }
        if (text.length === 1) {
          if (/[a-z]/i.test(text)) return text.toUpperCase();
          if (/[0-9]/.test(text)) return text;
          return '';
        }
        return '';
      }

      function parseShortcutBinding(raw) {
        const parts = String(raw || '')
          .split('+')
          .map((item) => item.trim())
          .filter(Boolean);
        if (parts.length === 0) return null;
        let primary = false;
        let alt = false;
        let shift = false;
        let key = '';
        parts.forEach((part) => {
          const lower = part.toLowerCase();
          if (
            lower === 'ctrl' ||
            lower === 'control' ||
            lower === 'cmd' ||
            lower === 'command' ||
            lower === 'meta' ||
            lower === 'primary'
          ) {
            primary = true;
            return;
          }
          if (lower === 'alt' || lower === 'option') {
            alt = true;
            return;
          }
          if (lower === 'shift') {
            shift = true;
            return;
          }
          if (key) {
            key = '';
            return;
          }
          key = normalizeShortcutKeyToken(part);
        });
        if (!key) return null;
        if (!primary && !alt && !shift) return null;
        return { primary, alt, shift, key };
      }

      function serializeShortcutBinding(binding) {
        if (!binding || !binding.key) return '';
        const parts = [];
        if (binding.primary) parts.push('Ctrl');
        if (binding.alt) parts.push('Alt');
        if (binding.shift) parts.push('Shift');
        parts.push(binding.key);
        return parts.join('+');
      }

      function normalizeShortcutBinding(raw, fallback) {
        const parsed = parseShortcutBinding(raw);
        if (parsed) return serializeShortcutBinding(parsed);
        const fallbackParsed = parseShortcutBinding(fallback);
        return fallbackParsed ? serializeShortcutBinding(fallbackParsed) : '';
      }

      function buildShortcutBindingFromEvent(event) {
        const key = normalizeShortcutKeyToken(event && event.key);
        if (!key) return '';
        const binding = {
          primary: Boolean(event && (event.ctrlKey || event.metaKey)),
          alt: Boolean(event && event.altKey),
          shift: Boolean(event && event.shiftKey),
          key,
        };
        if (!binding.primary && !binding.alt && !binding.shift) return '';
        return serializeShortcutBinding(binding);
      }

      function shortcutMatchesEvent(event, binding) {
        const parsed = parseShortcutBinding(binding);
        if (!parsed) return false;
        const key = normalizeShortcutKeyToken(event && event.key);
        if (!key || key !== parsed.key) return false;
        const primary = Boolean(event && (event.ctrlKey || event.metaKey));
        if (primary !== parsed.primary) return false;
        if (Boolean(event && event.altKey) !== parsed.alt) return false;
        if (Boolean(event && event.shiftKey) !== parsed.shift) return false;
        return true;
      }

      function bindShortcutInput(input, settingsKey, fallback) {
        if (!input) return;
        input.addEventListener('keydown', (event) => {
          if (event.key === 'Tab') return;
          event.preventDefault();
          event.stopPropagation();
          if (event.key === 'Escape') {
            settingsState[settingsKey] = normalizeShortcutBinding('', fallback);
            input.value = settingsState[settingsKey];
            saveSettingsToBackend();
            return;
          }
          const binding = buildShortcutBindingFromEvent(event);
          if (!binding) return;
          settingsState[settingsKey] = normalizeShortcutBinding(binding, fallback);
          input.value = settingsState[settingsKey];
          saveSettingsToBackend();
        });
        input.addEventListener('focus', () => {
          input.select();
        });
      }

      const settingsState = {
        notifications_enabled: true,
        audio_enabled: true,
        volume: 0.8,
        silence_timeout_ms: 30000,
        llm_enabled: false,
        llm_tool: 'codex',
        character_id: 'default',
        log_retention_lines: 20000,
        terminal_watcher_enabled: false,
        terminal_font_family: terminalSettingsDefaults.fontFamily,
        terminal_font_size: terminalSettingsDefaults.fontSize,
        terminal_theme:
          document.documentElement.dataset.theme === 'light'
            ? 'light'
            : terminalSettingsDefaults.theme,
        terminal_theme_palette:
          (() => {
            const value = String(document.documentElement.dataset.themePalette || '')
              .trim()
              .toLowerCase();
            return value.startsWith('light-') || value.startsWith('dark-')
              ? value
              : terminalSettingsDefaults.themePalette;
          })(),
        terminal_scrollback_lines: terminalSettingsDefaults.scrollbackLines,
        terminal_copy_on_select: terminalSettingsDefaults.copyOnSelect,
        terminal_internal_commands_enabled: true,
        terminal_shell_kind: 'cmd',
        terminal_wsl_distro: '',
        terminal_keybind_arrange: terminalKeybindDefaults.arrange,
        terminal_keybind_focus_next: terminalKeybindDefaults.focusNext,
        terminal_keybind_focus_prev: terminalKeybindDefaults.focusPrev,
      };
      const DEFAULT_SCROLLBACK_LINES = terminalSettingsDefaults.scrollbackLines;
      const characterBundles = new Set(['default']);
      let ipcSessionId = null;
      let debugTerminalEnabled =
        new URLSearchParams(window.location.search).get('debug_terminal') === '1';
      const TERMINAL_DEBUG_UI_STORAGE_KEY = 'nagomi_terminal_debug_ui';
      let terminalDebugUiVisible = true;
      // Terminal debug buffer avoids per-keystroke console spam / ターミナルのデバッグログをバッファして console 連打を避ける
      const TERMINAL_DEBUG_BUFFER_LIMIT = 800;
      const terminalDebugBuffer = [];
      let terminalDebugCount = 0;
      window.__setTerminalDebug = (enabled) => {
        debugTerminalEnabled = Boolean(enabled);
      };
      window.__getTerminalDebugBuffer = () => terminalDebugBuffer.slice();
      window.__clearTerminalDebug = () => {
        terminalDebugBuffer.length = 0;
      };
      window.__terminalDebugStats = () => ({
        total: terminalDebugCount,
        buffered: terminalDebugBuffer.length,
        limit: TERMINAL_DEBUG_BUFFER_LIMIT,
      });
      window.__dumpTerminalDebug = (options = {}) => {
        const rawLimit = Number(options.limit);
        const limit = Number.isFinite(rawLimit)
          ? Math.max(1, Math.floor(rawLimit))
          : terminalDebugBuffer.length;
        const start = Math.max(0, terminalDebugBuffer.length - limit);
        const slice = terminalDebugBuffer.slice(start);
        if (options.log !== false) {
          console.debug('[terminal-debug] dump', {
            total: terminalDebugCount,
            buffered: terminalDebugBuffer.length,
            returning: slice.length,
          });
          slice.forEach((entry) => {
            console.debug(`[terminal-debug] ${entry.label}`, entry.payload || {});
          });
        }
        if (options.clear) {
          terminalDebugBuffer.length = 0;
        }
        return slice;
      };

      function debugTerminal(label, payload) {
        if (!debugTerminalEnabled) return;
        terminalDebugCount += 1;
        terminalDebugBuffer.push({
          ts: Date.now(),
          label,
          payload: payload || null,
        });
        if (terminalDebugBuffer.length > TERMINAL_DEBUG_BUFFER_LIMIT) {
          terminalDebugBuffer.splice(
            0,
            terminalDebugBuffer.length - TERMINAL_DEBUG_BUFFER_LIMIT
          );
        }
      }

      function loadTerminalDebugUiVisible() {
        try {
          const raw = localStorage.getItem(TERMINAL_DEBUG_UI_STORAGE_KEY);
          if (raw === '0' || raw === 'false') return false;
          if (raw === '1' || raw === 'true') return true;
        } catch {
          return true;
        }
        return true;
      }

      function applyTerminalDebugUiVisible(visible) {
        terminalDebugUiVisible = Boolean(visible);
        if (terminalShell) {
          terminalShell.classList.toggle('debug-ui-hidden', !terminalDebugUiVisible);
        }
        if (terminalDebugToggle) {
          terminalDebugToggle.textContent = terminalDebugUiVisible
            ? t('debug.ui_on')
            : t('debug.ui_off');
        }
        try {
          localStorage.setItem(
            TERMINAL_DEBUG_UI_STORAGE_KEY,
            terminalDebugUiVisible ? '1' : '0'
          );
        } catch {
          return;
        }
      }

      function visualizeText(raw, limit = 120) {
        if (!raw) return '';
        let out = '';
        for (const ch of raw) {
          const code = ch.charCodeAt(0);
          if (ch === '\r') {
            out += '\\r';
          } else if (ch === '\n') {
            out += '\\n';
          } else if (ch === '\t') {
            out += '\\t';
          } else if (code < 0x20) {
            out += `\\x${code.toString(16).padStart(2, '0')}`;
          } else {
            out += ch;
          }
          if (out.length >= limit) {
            out += '...';
            break;
          }
        }
        return out;
      }

      function normalizeScrollback(value) {
        const lines = Number(value);
        if (!Number.isFinite(lines)) return DEFAULT_SCROLLBACK_LINES;
        return Math.max(1, Math.floor(lines));
      }

      function getInvoke() {
        if (!window.__TAURI__) return null;
        return window.__TAURI__.core && window.__TAURI__.core.invoke
          ? window.__TAURI__.core.invoke
          : window.__TAURI__.invoke || null;
      }

      function getEventListen() {
        if (!window.__TAURI__) return null;
        return window.__TAURI__.event && window.__TAURI__.event.listen
          ? window.__TAURI__.event.listen
          : null;
      }

      async function ensureIpcSession() {
        if (ipcSessionId) return ipcSessionId;
        let invoke = getInvoke();
        if (!invoke) {
          for (let i = 0; i < 60; i += 1) {
            await new Promise((resolve) => setTimeout(resolve, 100));
            invoke = getInvoke();
            if (invoke) break;
          }
        }
        if (!invoke) return null;
        for (let attempt = 0; attempt < 10; attempt += 1) {
          try {
            const snapshot = await invoke('ipc_session_open', { clientEpoch: Date.now() });
            const sessionId = snapshot && snapshot.sessionId ? snapshot.sessionId : null;
            if (!sessionId) {
              return null;
            }
            ipcSessionId = sessionId;
            window.__ipcSessionId = sessionId;
            return sessionId;
          } catch {
            await new Promise((resolve) => setTimeout(resolve, 200));
          }
        }
        return null;
      }

      async function invokeWithSession(command, payload) {
        const invoke = getInvoke();
        if (!invoke) return null;
        const sessionId = await ensureIpcSession();
        if (!sessionId) return null;
        const args = payload ? { ...payload, ipcSessionId: sessionId } : { ipcSessionId: sessionId };
        return invoke(command, args);
      }

      function updateModeSubtitle(view) {
        if (!modeSubtitle) return;
        if (view === 'settings' || view === 'watcher') {
          modeSubtitle.textContent = '';
          return;
        }
        let key = '';
        if (view === 'chat') key = 'mode.chat';
        if (view === 'run') key = 'mode.run';
        if (view === 'terminal') key = 'mode.terminal';
        modeSubtitle.textContent = key ? t(key) : '';
      }

      function applyView(view) {
        if (!view) return;
        if (view === 'settings') {
          document.body.classList.add('settings-only');
          document.documentElement.classList.add('settings-only');
        } else {
          document.body.classList.remove('settings-only');
          document.documentElement.classList.remove('settings-only');
        }
        if (view === 'watcher') {
          document.body.classList.add('watcher-only');
          document.documentElement.classList.add('watcher-only');
        } else {
          document.body.classList.remove('watcher-only');
          document.documentElement.classList.remove('watcher-only');
        }
        if (view === 'terminal') {
          document.body.classList.add('terminal-only');
          document.documentElement.classList.add('terminal-only');
        } else {
          document.body.classList.remove('terminal-only');
          document.documentElement.classList.remove('terminal-only');
        }
        updateModeSubtitle(view);
        if (view === 'watcher') {
          chatMain.classList.add('hidden');
          chatToolbar.classList.add('hidden');
          runBoard.classList.add('hidden');
          settingsBoard.classList.add('hidden');
          if (terminalBoard) {
            terminalBoard.classList.remove('hidden');
          }
          if (modeSwitch) {
            modeSwitch.classList.add('hidden');
          }
          applyTerminalWatcherVisibility();
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              notifyWatcherWindowReady();
            });
          });
          return;
        }
        if (view === 'settings') {
          chatMain.classList.add('hidden');
          chatToolbar.classList.add('hidden');
          runBoard.classList.add('hidden');
          if (terminalBoard) {
            terminalBoard.classList.add('hidden');
          }
          settingsBoard.classList.remove('hidden');
          if (modeSwitch) {
            modeSwitch.classList.add('hidden');
          }
          if (isWindowsRuntime) {
            loadWslDistros();
          }
          return;
        }
        settingsBoard.classList.add('hidden');
        if (modeSwitch) {
          modeSwitch.classList.remove('hidden');
        }
        if (terminalBoard) {
          terminalBoard.classList.add('hidden');
        }
        if (view === 'run') {
          chatMain.classList.add('hidden');
          chatToolbar.classList.add('hidden');
          runBoard.classList.remove('hidden');
        } else if (view === 'terminal') {
          chatMain.classList.add('hidden');
          chatToolbar.classList.add('hidden');
          runBoard.classList.add('hidden');
          if (terminalBoard) {
            terminalBoard.classList.remove('hidden');
          }
        } else {
          chatMain.classList.remove('hidden');
          chatToolbar.classList.remove('hidden');
          runBoard.classList.add('hidden');
        }

        if (view === 'terminal' && modeSwitch) {
          modeSwitch.classList.add('hidden');
        }

        if (view === 'terminal') {
          if (!terminalInitialized) {
            setTimeout(() => initTerminal(), 0);
          } else {
            setTimeout(() => {
              if (!fitAddon || !terminal) return;
              fitAddon.fit();
              resizeTerminal();
            }, 0);
          }
        }

        if (modeChips.length) {
          modeChips.forEach((item) => item.classList.remove('active'));
          const next = Array.from(modeChips).find((chip) => chip.dataset.mode === view);
          if (next) {
            next.classList.add('active');
          }
        }
      }

      function setFollow(enabled) {
        followEnabled = enabled;
        followState.textContent = enabled ? t('toggle.on') : t('toggle.off');
      }

      async function arrangeWindows() {
        try {
          await invokeWithSession('arrange_terminal_windows');
        } catch {
          return;
        }
      }

      async function ensureTerminalWindow(sessionId) {
        if (!sessionId) return false;
        try {
          await invokeWithSession('open_terminal_window', { sessionId });
          await invokeWithSession('pickup_terminal_window', { sessionId });
          return true;
        } catch {
          return false;
        }
      }

      async function pickupTerminalWindowByIndex(index) {
        try {
          await invokeWithSession('pickup_terminal_window_by_index', { index });
          return true;
        } catch {
          return false;
        }
      }

      async function pickupCurrentTerminalWindowIfNeeded(source = 'unknown') {
        if (!terminalSessionId) return false;
        if (focusTransitionActive) return false;
        if (terminalPickupInFlight) return false;
        const now = Date.now();
        if (now - terminalPickupLastAt < terminalPickupCooldownMs) {
          return false;
        }
        terminalPickupInFlight = true;
        terminalPickupLastAt = now;
        try {
          await invokeWithSession('pickup_terminal_window', { sessionId: terminalSessionId });
          return true;
        } catch {
          return false;
        } finally {
          // Coalesce click+focus duplicate pickup requests from the same interaction.
          setTimeout(() => {
            terminalPickupInFlight = false;
          }, source === 'focus' ? 80 : 40);
        }
      }

      async function focusNextTerminal(direction) {
        try {
          await invokeWithSession('focus_next_terminal_window', { direction });
        } catch {
          return;
        }
      }

      async function openTerminalWindowByIndexSamePosition(index) {
        try {
          await invokeWithSession('open_terminal_window_by_index_same_position', { index });
          return true;
        } catch {
          return false;
        }
      }

      async function openTerminalWindowSamePositionSelected() {
        try {
          await invokeWithSession('open_terminal_window_same_position_selected');
          return true;
        } catch {
          return false;
        }
      }

      async function openTerminalWindowSamePositionForSession(sessionId) {
        if (!sessionId) return false;
        try {
          await invokeWithSession('open_terminal_window_same_position_for_session', { sessionId });
          return true;
        } catch {
          return false;
        }
      }

      function terminalThemePalette(theme, palette) {
        const normalizedMode = normalizeThemeMode(theme);
        const key = normalizeThemePalette(normalizedMode, palette);
        const palettes = {
          'light-sand': {
            background: '#f1ede6',
            foreground: '#1f2429',
            cursor: '#1f7a8c',
            selection: 'rgba(31, 122, 140, 0.2)',
          },
          'light-sage': {
            background: '#eef4ec',
            foreground: '#1f2b22',
            cursor: '#2c7a4f',
            selection: 'rgba(44, 122, 79, 0.2)',
          },
          'light-sky': {
            background: '#edf3f9',
            foreground: '#1d2838',
            cursor: '#2e5f9e',
            selection: 'rgba(46, 95, 158, 0.22)',
          },
          'light-mono': {
            background: '#ffffff',
            foreground: '#111111',
            cursor: '#222222',
            selection: 'rgba(17, 17, 17, 0.2)',
          },
          'dark-ink': {
            background: '#0d1117',
            foreground: '#e6edf3',
            cursor: '#f6d28b',
            selection: 'rgba(246, 210, 139, 0.3)',
          },
          'dark-ocean': {
            background: '#09131c',
            foreground: '#dcecf7',
            cursor: '#5cb8df',
            selection: 'rgba(92, 184, 223, 0.28)',
          },
          'dark-ember': {
            background: '#161110',
            foreground: '#f0e4d6',
            cursor: '#d89a68',
            selection: 'rgba(216, 154, 104, 0.3)',
          },
          'dark-mono': {
            background: '#0a0a0a',
            foreground: '#f3f3f3',
            cursor: '#ffffff',
            selection: 'rgba(243, 243, 243, 0.26)',
          },
        };
        return palettes[key] || palettes[themePaletteDefault(normalizedMode)];
      }

      function applyTerminalSettings() {
        if (!terminal) return;
        terminal.options.fontFamily = settingsState.terminal_font_family;
        terminal.options.fontSize = settingsState.terminal_font_size;
        terminal.options.theme = terminalThemePalette(
          settingsState.terminal_theme,
          settingsState.terminal_theme_palette
        );
        terminal.options.scrollback = normalizeScrollback(settingsState.terminal_scrollback_lines);
        terminalCopyOnSelect = settingsState.terminal_copy_on_select;
      }

      async function startTerminalSession() {
        if (!terminal) return;
        terminalSessionReady = false;
        try {
          console.debug('[terminal] start_session', {
            sessionId: terminalSessionId,
            cols: terminal.cols,
            rows: terminal.rows,
          });
          await invokeWithSession('start_terminal_session', {
            sessionId: terminalSessionId,
            cols: terminal.cols,
            rows: terminal.rows,
          });
          terminalSessionReady = true;
          if (rawInputQueue) {
            flushNow();
          } else if (sendQueue) {
            if (typeof queueMicrotask === 'function') {
              queueMicrotask(drainSendQueue);
            } else {
              setTimeout(drainSendQueue, 0);
            }
          }
        } catch {
          terminalSessionReady = false;
          return;
        }
      }

      async function registerTerminalSession() {
        try {
          console.debug('[terminal] register_session', { sessionId: terminalSessionId });
          await invokeWithSession('register_terminal_session', { sessionId: terminalSessionId });
        } catch {
          return;
        }
      }

      function enqueueSend(text) {
        if (!text) return;
        sendQueue += text;
      }

      function queueDrainSendQueue() {
        if (sendRetryTimer) {
          clearTimeout(sendRetryTimer);
          sendRetryTimer = null;
        }
        if (typeof queueMicrotask === 'function') {
          queueMicrotask(drainSendQueue);
        } else {
          setTimeout(drainSendQueue, 0);
        }
      }

      function scheduleSendRetry(reason) {
        if (sendRetryTimer) return;
        debugTerminal('send-input-retry', { reason, retry: sendRetryCount, queued: sendQueue.length });
        sendRetryTimer = setTimeout(() => {
          sendRetryTimer = null;
          drainSendQueue();
        }, SEND_RETRY_DELAY_MS);
      }

      async function drainSendQueue() {
        if (sendInFlight) return;
        if (!sendQueue) return;
        if (!terminalSessionReady) {
          scheduleSendRetry('session-not-ready');
          return;
        }
        sendInFlight = true;
        let chunk = '';
        try {
          chunk = sendQueue;
          sendQueue = '';
          debugTerminal('send-input', { size: chunk.length, preview: visualizeText(chunk) });
          const sendStart = performance.now();
          await invokeWithSession('terminal_send_input', {
            sessionId: terminalSessionId,
            text: chunk,
          });
          const sendElapsed = performance.now() - sendStart;
          sendRetryCount = 0;
          if (sendElapsed > 24) {
            controlInputFlushMs = CONTROL_INPUT_FLUSH_MAX;
          } else if (sendElapsed > 16) {
            controlInputFlushMs = Math.min(
              CONTROL_INPUT_FLUSH_MAX,
              Math.max(CONTROL_INPUT_FLUSH_MIN, controlInputFlushMs + 4)
            );
          } else if (sendElapsed < 8) {
            controlInputFlushMs = Math.max(CONTROL_INPUT_FLUSH_MIN, controlInputFlushMs - 1);
          }
          if (sendQueue) {
            queueDrainSendQueue();
          }
        } catch (error) {
          const message =
            error && typeof error === 'object' && 'message' in error
              ? String(error.message || '')
              : String(error || '');
          sendQueue = `${chunk}${sendQueue}`;
          sendRetryCount += 1;
          debugTerminal('send-input-error', {
            retry: sendRetryCount,
            size: chunk.length,
            message: message || 'unknown',
          });
          if (sendRetryCount > SEND_RETRY_MAX) {
            debugTerminal('send-input-drop', {
              reason: 'retry-limit',
              retries: sendRetryCount,
              dropped: chunk.length,
            });
            sendRetryCount = 0;
            sendQueue = '';
            return;
          }
          scheduleSendRetry(message || 'invoke-error');
        } finally {
          sendInFlight = false;
        }
      }

      function sendTerminalInput(text) {
        if (captureInputLinesFromSendQueue) {
          ingestInputLines(text);
        }
        enqueueSend(text);
      }

      function isControlish(text) {
        return (
          text.includes('\x7f') ||
          text.includes('\b') ||
          text.includes('\r') ||
          text.startsWith('\x1b')
        );
      }

      function flushNow() {
        if (!rawInputQueue) return;
        const queuedInput = rawInputQueue;
        rawInputQueue = '';
        if (captureInputLinesFromSendQueue) {
          ingestInputLines(queuedInput);
        }
        let nextForward = queuedInput;
        if (nagomiInternalEnabled) {
          try {
            const processed = processNagomiInternalInputChunk(queuedInput);
            nextForward = processed.forwardText;
            if (processed.localEchoText) {
              emitLocalTerminalOutput(processed.localEchoText, 'internal-echo');
            }
            if (processed.internalCommands.length > 0) {
              debugTerminal('internal-command', {
                count: processed.internalCommands.length,
                lines: processed.internalCommands.map((item) => item.line),
              });
              for (const invocation of processed.internalCommands) {
                const response = executeNagomiInternalCommand(invocation.command);
                if (response) {
                  emitLocalTerminalOutput(response, 'internal-command');
                }
              }
              nextForward += '\r';
            }
          } catch (error) {
            rollbackNagomiInternalCommands('internal-processing-error', error);
            nextForward = queuedInput;
          }
        }
        if (nextForward) {
          enqueueSend(nextForward);
        }
        if (controlFlushTimer) {
          clearTimeout(controlFlushTimer);
          controlFlushTimer = null;
        }
        if (!sendInFlight) {
          queueDrainSendQueue();
        }
      }

      function flushOnRaf() {
        if (rafScheduled) return;
        rafScheduled = true;
        requestAnimationFrame(() => {
          rafScheduled = false;
          flushNow();
        });
      }

      function ingestInput(text) {
        if (!text) return;
        if (agentObserved) {
          clearAgentObservedState('input sent');
        }
        if (!captureInputLinesFromSendQueue) {
          ingestInputLines(text);
        }
        const controlInput = isControlish(text);
        if (controlInput) {
          forceDrainOutputNow();
        }
        rawInputQueue += text;
        if (controlInput) {
          if (controlFlushTimer) return;
          controlFlushTimer = setTimeout(() => {
            controlFlushTimer = null;
            flushNow();
          }, controlInputFlushMs);
        } else {
          flushOnRaf();
        }
      }

      function enqueueTerminalOutput(chunk) {
        if (!chunk) return;
        outputChunks.push(chunk);
        outputBytes += chunk.length;
        while (outputBytes > MAX_TERMINAL_OUTPUT_BUFFER && outputHead < outputChunks.length) {
          const dropped = outputChunks[outputHead];
          if (!dropped) break;
          outputBytes -= dropped.length;
          outputHead += 1;
        }
        if (outputHead > 128 && outputHead * 2 > outputChunks.length) {
          outputChunks.splice(0, outputHead);
          outputHead = 0;
        }
        if (outputScheduled || outputWriting) return;
        outputScheduled = true;
        requestAnimationFrame(() => {
          outputScheduled = false;
          drainTerminalOutput();
        });
      }

      function drainTerminalOutput() {
        if (!terminal) return;
        if (outputWriting) return;
        if (outputHead >= outputChunks.length) return;
        const drainBudgetChars = terminalOutputDrainMax;
        const parts = [];
        let consumedChars = 0;
        while (
          outputHead < outputChunks.length &&
          consumedChars < drainBudgetChars &&
          parts.length < TERMINAL_OUTPUT_DRAIN_MAX_PARTS
        ) {
          const current = outputChunks[outputHead];
          if (!current) {
            outputHead += 1;
            continue;
          }
          const remaining = drainBudgetChars - consumedChars;
          if (current.length <= remaining) {
            parts.push(current);
            consumedChars += current.length;
            outputBytes -= current.length;
            outputHead += 1;
            continue;
          }
          if (remaining > 0) {
            parts.push(current.slice(0, remaining));
            outputChunks[outputHead] = current.slice(remaining);
            consumedChars += remaining;
            outputBytes -= remaining;
          }
          break;
        }
        if (!parts.length) return;
        if (outputHead > 128 && outputHead * 2 > outputChunks.length) {
          outputChunks.splice(0, outputHead);
          outputHead = 0;
        }
        if (outputHead >= outputChunks.length) {
          outputChunks.length = 0;
          outputHead = 0;
          outputBytes = 0;
        }
        const chunk = parts.join('');
        outputWriting = true;
        const writeStart = performance.now();
        terminal.write(chunk, () => {
          const dt = performance.now() - writeStart;
          terminalOutputLastWriteMs = dt;
          if (dt > 16 && terminalOutputDrainMax > TERMINAL_OUTPUT_DRAIN_MIN) {
            terminalOutputDrainMax = Math.max(
              TERMINAL_OUTPUT_DRAIN_MIN,
              Math.floor(terminalOutputDrainMax / 2)
            );
          } else if (dt < 8 && terminalOutputDrainMax < TERMINAL_OUTPUT_DRAIN_MAX_CAP) {
            terminalOutputDrainMax = Math.min(
              TERMINAL_OUTPUT_DRAIN_MAX_CAP,
              terminalOutputDrainMax + 4096
            );
          }
          outputWriting = false;
          if (outputHead < outputChunks.length) {
            requestAnimationFrame(drainTerminalOutput);
          }
        });
      }

      function forceDrainOutputNow() {
        if (!terminal) return;
        if (outputWriting) return;
        if (outputHead >= outputChunks.length) return;
        drainTerminalOutput();
      }

      function appendPendingEcho(text) {
        if (!text) return;
        pendingEcho += text;
        if (pendingEcho.length > MAX_PENDING_ECHO) {
          debugTerminal('pending-echo-overflow', { max: MAX_PENDING_ECHO });
          pendingEcho = '';
        }
        if (pendingEchoTimer) {
          clearTimeout(pendingEchoTimer);
        }
        pendingEchoTimer = setTimeout(() => {
          debugTerminal('pending-echo-expired');
          pendingEcho = '';
          pendingEchoTimer = null;
        }, PENDING_ECHO_TTL_MS);
        debugTerminal('pending-echo-append', {
          len: pendingEcho.length,
          preview: visualizeText(pendingEcho),
        });
      }

      function clearPendingEcho(reason) {
        debugTerminal('pending-echo-clear', { reason: reason || 'unknown' });
        pendingEcho = '';
        if (pendingEchoTimer) {
          clearTimeout(pendingEchoTimer);
          pendingEchoTimer = null;
        }
      }

      function isAsciiPrintable(char) {
        const code = char.charCodeAt(0);
        return code >= 0x20 && code <= 0x7e;
      }

      function isPrintableInputChar(char) {
        if (!char) return false;
        if (char === '\x1b' || char === '\x7f') return false;
        const code = char.charCodeAt(0);
        return code >= 0x20;
      }

      function buildLocalEcho(data) {
        let echoText = '';
        let pendingText = '';
        for (const char of data) {
          if (char === '\r' || char === '\n') {
            echoText += '\r\n';
            pendingText += '\r\n';
            continue;
          }
          if (char === '\t') {
            echoText += '\t';
            pendingText += '\t';
            continue;
          }
          if (isAsciiPrintable(char)) {
            echoText += char;
            pendingText += char;
          }
        }
        return { echoText, pendingText };
      }

      function splitAnsiParts(input) {
        const parts = [];
        let i = 0;
        while (i < input.length) {
          const ch = input[i];
          if (ch === '\x1b') {
            const next = input[i + 1];
            if (next === '[') {
              let j = i + 2;
              while (j < input.length) {
                const code = input.charCodeAt(j);
                if (code >= 0x40 && code <= 0x7e) {
                  j += 1;
                  break;
                }
                j += 1;
              }
              parts.push({ type: 'ansi', value: input.slice(i, j) });
              i = j;
              continue;
            }
            if (next === ']') {
              let j = i + 2;
              while (j < input.length) {
                if (input[j] === '\x07') {
                  j += 1;
                  break;
                }
                if (input[j] === '\x1b' && input[j + 1] === '\\') {
                  j += 2;
                  break;
                }
                j += 1;
              }
              parts.push({ type: 'ansi', value: input.slice(i, j) });
              i = j;
              continue;
            }
            const j = Math.min(i + 2, input.length);
            parts.push({ type: 'ansi', value: input.slice(i, j) });
            i = j;
            continue;
          }
          let j = i;
          while (j < input.length && input[j] !== '\x1b') {
            j += 1;
          }
          parts.push({ type: 'text', value: input.slice(i, j) });
          i = j;
        }
        return parts;
      }

      function stripEchoFromText(text) {
        if (!pendingEcho || !text) return text;
        if (text.startsWith(pendingEcho)) {
          const nextText = text.slice(pendingEcho.length);
          debugTerminal('suppress-drop-prefix', {
            pendingLen: pendingEcho.length,
            textLen: text.length,
            nextLen: nextText.length,
          });
          pendingEcho = '';
          return nextText;
        }
        if (pendingEcho.startsWith(text)) {
          debugTerminal('suppress-drop-chunk', {
            pendingLen: pendingEcho.length,
            textLen: text.length,
          });
          pendingEcho = pendingEcho.slice(text.length);
          return '';
        }
        debugTerminal('suppress-miss', {
          pendingLen: pendingEcho.length,
          textLen: text.length,
          pendingPreview: visualizeText(pendingEcho),
          textPreview: visualizeText(text),
        });
        return text;
      }

      function suppressEcho(chunk) {
        if (!suppressEchoActive) return chunk;
        if (!pendingEcho || !chunk) return chunk;
        const parts = splitAnsiParts(chunk);
        let output = '';
        for (const part of parts) {
          if (part.type === 'ansi') {
            output += part.value;
          } else {
            output += stripEchoFromText(part.value);
          }
        }
        return output;
      }

      function enqueueTerminalInput(text) {
        if (!text) return;
        inputChunkHistory.push({
          ts: Date.now(),
          preview: visualizeText(text, 120),
        });
        if (inputChunkHistory.length > INPUT_CHUNK_HISTORY_LIMIT) {
          inputChunkHistory.splice(0, inputChunkHistory.length - INPUT_CHUNK_HISTORY_LIMIT);
        }
        dataInputSeenAt = Date.now();
        let sawPrintable = false;
        for (const ch of text) {
          if (isPrintableInputChar(ch)) {
            sawPrintable = true;
            break;
          }
        }
        if (sawPrintable && inputCaptureMode !== 'textarea') {
          inputCaptureMode = 'data';
          if (keyInputBuffer) keyInputBuffer = '';
        }
        setLastTerminalEvent('input-chunk', visualizeText(text, 24));
        debugTerminal('input-data', {
          size: text.length,
          preview: visualizeText(text),
          composing: false,
        });
        const hasEscape = text.includes('\x1b');
        const hasBackspace = text.includes('\x7f') || text.includes('\b');
        if (hasBackspace || hasEscape) {
          debugTerminal('control-input', { hasBackspace, hasEscape });
          suppressEchoActive = false;
          clearPendingEcho('control-input');
        }
        // Local echo disabled for correctness / 繝ｭ繝ｼ繧ｫ繝ｫ繧ｨ繧ｳ繝ｼ縺ｯ豁｣遒ｺ諤ｧ蜆ｪ蜈医〒辟｡蜉ｹ蛹・
        ingestInput(text);
        // Fallback: ensure tool-start detection even if input parsing missed it.
        // フォールバック: 入力解析の取りこぼし時もツール開始検知を拾う。
        if (!agentSessionActive && text.includes('\r')) {
          const parts = text.split(/\r\n|\r|\n/);
          const candidate = parts.length > 1 ? parts[parts.length - 2] : parts[0];
          handleTerminalLine(candidate);
        }
      }

      function registerTestHooks() {
        // Test hooks for automation / 自動テスト用のフック
        const api = Object.freeze({
          getTerminalSessionId() {
            return terminalSessionId;
          },
          getObservedState() {
            return {
              merged: mergedObserved ? { ...mergedObserved } : null,
              terminal: terminalObserved ? { ...terminalObserved } : null,
              agent: agentObserved ? { ...agentObserved } : null,
            };
          },
          getInternalState() {
            return {
              commandActive: terminalCommandActive,
              hasUserCommand: terminalHasUserCommand,
              sticky: terminalStickyObserved ? { ...terminalStickyObserved } : null,
              agentActive: agentSessionActive,
              agentSource: agentSessionSource,
              lastTail: terminalLastChunkTail ? terminalLastChunkTail.slice(-160) : '',
              outputTail: outputTailBuffer ? outputTailBuffer.slice(-160) : '',
              internalCommandsEnabled: nagomiInternalEnabled,
              ipcSessionId,
              terminalSessionId,
            };
          },
          getWatcherTitle() {
            return terminalWatcher ? terminalWatcher.title : '';
          },
          sendTerminalInput(text) {
            if (typeof text !== 'string') return false;
            enqueueTerminalInput(text);
            return true;
          },
          emitHookState(payload) {
            if (!payload || typeof payload !== 'object') return false;
            handleHookEvent(payload);
            return true;
          },
        });
        window.nagomiTest = api;
        return api;
      }

      async function resizeTerminal() {
        if (!terminal) return;
        try {
          console.debug('[terminal] resize', {
            sessionId: terminalSessionId,
            cols: terminal.cols,
            rows: terminal.rows,
          });
          await invokeWithSession('terminal_resize', {
            sessionId: terminalSessionId,
            cols: terminal.cols,
            rows: terminal.rows,
          });
        } catch {
          return;
        }
      }

      function setupTerminalEvents() {
        if (!terminal) return;
        terminal.onData((data) => {
          if (!data) return;
          enqueueTerminalInput(data);
        });
        terminal.onKey((event) => {
          if (captureInputLinesFromSendQueue) return;
          if (!event || !event.domEvent) return;
          const domEvent = event.domEvent;
          if (domEvent.ctrlKey || domEvent.metaKey || domEvent.altKey) return;
          const key = domEvent.key;
          const dataFresh = Date.now() - dataInputSeenAt < 1000;
          terminalLastActivityAt = Date.now();
          lastKeyLabel = key || '';
          setLastTerminalEvent('key', key);
          if (key === 'Enter') {
            if (!dataInputLineActive && !dataFresh && keyInputBuffer) {
              handleTerminalLine(keyInputBuffer);
              keyInputBuffer = '';
              skipNextCarriage = true;
            } else {
              skipNextCarriage = false;
            }
            inputSawCarriage = true;
            return;
          }
          if (key === 'Backspace') {
            if (!dataInputLineActive && !dataFresh) {
              inputCaptureMode = 'key';
              keyInputBuffer = keyInputBuffer.slice(0, -1);
            }
            return;
          }
          if (key && key.length === 1) {
            if (!dataInputLineActive && !dataFresh) {
              inputCaptureMode = 'key';
              keyInputBuffer += key;
            }
          }
        });
        document.addEventListener(
          'keydown',
          (event) => {
            if (!isTerminalView) return;
            if (!event || event.defaultPrevented) return;
            if (captureInputLinesFromSendQueue) return;
            if (inputCaptureMode === 'key') return;
            if (event.ctrlKey || event.metaKey || event.altKey) return;
            const key = event.key;
            if (!key) return;
            const dataFresh = Date.now() - dataInputSeenAt < 1000;
            terminalLastActivityAt = Date.now();
            lastKeyLabel = key;
            setLastTerminalEvent('global-key', key);
            if (key === 'Enter') {
              if (!dataInputLineActive && !dataFresh) {
                const candidate = inputLineBuffer || keyInputBuffer;
                if (candidate) {
                  handleTerminalLine(candidate);
                  skipNextCarriage = true;
                } else {
                  skipNextCarriage = false;
                }
                inputLineBuffer = '';
                keyInputBuffer = '';
              } else {
                skipNextCarriage = false;
              }
              inputSawCarriage = true;
              return;
            }
            if (key === 'Backspace') {
              if (!dataInputLineActive && !dataFresh) {
                inputLineBuffer = inputLineBuffer.slice(0, -1);
                keyInputBuffer = keyInputBuffer.slice(0, -1);
              }
              return;
            }
            if (key.length === 1) {
              if (!dataInputLineActive && !dataFresh) {
                if (inputCaptureMode === 'auto') inputCaptureMode = 'global';
                inputLineBuffer += key;
                keyInputBuffer += key;
              }
            }
          },
          true
        );
        if (terminal.textarea) {
          terminal.textarea.addEventListener(
            'keydown',
            (event) => {
              if (!event) return;
              if (captureInputLinesFromSendQueue) return;
              if (event.ctrlKey || event.metaKey || event.altKey) return;
              if (event.key === 'Enter') {
                const dataFresh = Date.now() - dataInputSeenAt < 1000;
                if (!dataInputLineActive && !dataFresh) {
                  if (inputCaptureMode === 'auto') inputCaptureMode = 'textarea';
                  const candidate = inputLineBuffer || keyInputBuffer;
                  if (candidate) handleTerminalLine(candidate);
                  inputLineBuffer = '';
                  keyInputBuffer = '';
                  skipNextCarriage = true;
                } else {
                  skipNextCarriage = false;
                }
                inputSawCarriage = true;
              }
            },
            true
          );
          terminal.textarea.addEventListener(
            'input',
            (event) => {
              const data = event && typeof event.data === 'string' ? event.data : '';
              const text = data || terminal.textarea.value || '';
              if (!text) return;
              if (captureInputLinesFromSendQueue) return;
              if (Date.now() - dataInputSeenAt < 1000) return;
              if (inputCaptureMode === 'auto') inputCaptureMode = 'textarea';
              terminalLastActivityAt = Date.now();
              inputLineBuffer += text;
              keyInputBuffer += text;
              setLastTerminalEvent('text', visualizeText(text, 24));
            },
            true
          );
          terminal.textarea.addEventListener(
            'compositionend',
            (event) => {
              const data = event && typeof event.data === 'string' ? event.data : '';
              if (!data) return;
              if (captureInputLinesFromSendQueue) return;
              if (Date.now() - dataInputSeenAt < 1000) return;
              if (inputCaptureMode === 'auto') inputCaptureMode = 'textarea';
              terminalLastActivityAt = Date.now();
              inputLineBuffer += data;
              keyInputBuffer += data;
              setLastTerminalEvent('compose', visualizeText(data, 24));
            },
            true
          );
        }

        // Enable paste shortcuts (Windows-like behavior) / ペーストショートカットを有効化
        // - Ctrl+V: paste (fallback to ^V if clipboard read fails)
        // - Ctrl+Shift+V / Shift+Insert: paste
        terminal.attachCustomKeyEventHandler((event) => {
          try {
            if (!event || event.type !== 'keydown') return true;
            const key = String(event.key || '').toLowerCase();
            const isShiftInsert = event.shiftKey && key === 'insert';
            const isCtrlV = event.ctrlKey && !event.altKey && !event.metaKey && key === 'v';
            const isCtrlShiftV =
              event.ctrlKey && event.shiftKey && !event.altKey && !event.metaKey && key === 'v';
            if (!isCtrlV && !isCtrlShiftV && !isShiftInsert) return true;

            // Let the browser fire a real "paste" event (no permission prompt),
            // but prevent xterm from treating Ctrl+V as ^V.
            // ブラウザの paste イベントに任せて（許可ダイアログ無し）、xterm 側の ^V を抑止する
            if (terminal && typeof terminal.focus === 'function') {
              queueMicrotask(() => terminal.focus());
            }
            return false;
          } catch {
            return true;
          }
        });

        terminal.onSelectionChange(() => {
          if (!terminalCopyOnSelect) return;
          const selection = terminal.getSelection();
          if (!selection) return;
          navigator.clipboard.writeText(selection).catch(() => {});
        });
        const onPaste = async (event) => {
          let text = '';
          if (event && event.clipboardData && typeof event.clipboardData.getData === 'function') {
            text =
              event.clipboardData.getData('text/plain') ||
              event.clipboardData.getData('text') ||
              event.clipboardData.getData('Text') ||
              '';
          }
          if (!text) {
            return;
          }
          if (!text) return;
          // Prevent xterm's default paste to avoid double-send, and forward to PTY instead.
          // xterm の既定ペーストを止めて、PTY へ貼り付け文字列を送る（二重送信を避ける）
          if (event && typeof event.preventDefault === 'function') {
            event.preventDefault();
          }
          ingestInput(text);
        };

        if (terminal && terminal.textarea) {
          terminal.textarea.addEventListener('paste', onPaste, { capture: true });
        }
        if (terminalContainer) {
          terminalContainer.addEventListener('paste', onPaste, { capture: true });
        }
        window.addEventListener('beforeunload', () => {
          invokeWithSession('stop_terminal_session', { sessionId: terminalSessionId }).catch(
            () => {}
          );
        });
      }

      function initTerminal() {
        if (terminalInitialized || !terminalContainer || !window.Terminal || !window.FitAddon) {
          return;
        }
        terminalInitialized = true;
        console.debug('[terminal] init', { sessionId: terminalSessionId });
        terminal = new window.Terminal({
          fontFamily: settingsState.terminal_font_family,
          fontSize: settingsState.terminal_font_size,
          theme: terminalThemePalette(
            settingsState.terminal_theme,
            settingsState.terminal_theme_palette
          ),
          scrollback: settingsState.terminal_scrollback_lines,
          allowProposedApi: true,
        });
        fitAddon = new window.FitAddon.FitAddon();
        terminal.loadAddon(fitAddon);
        terminal.open(terminalContainer);
        terminalExitCode = null;
        terminalLastOutputAt = Date.now();
        terminalLastActivityAt = Date.now();
        terminalLastChunkTail = '';
        outputTailBuffer = '';
        lastTerminalEvent = { type: 'init', detail: '' };
        lastInputLine = '';
        inputCaptureMode = 'auto';
        keyInputBuffer = '';
        skipNextCarriage = false;
        lastKeyLabel = '';
        terminalSessionReady = false;
        sendQueue = '';
        rawInputQueue = '';
        sendInFlight = false;
        sendRetryCount = 0;
        if (sendRetryTimer) {
          clearTimeout(sendRetryTimer);
          sendRetryTimer = null;
        }
        if (controlFlushTimer) {
          clearTimeout(controlFlushTimer);
          controlFlushTimer = null;
        }
        inputChunkHistory.length = 0;
        dataInputSeenAt = 0;
        dataInputLineActive = false;
        agentSessionActive = false;
        agentSessionSource = null;
        inputLineBuffer = '';
        inputSawCarriage = false;
        resetNagomiInternalCapture();
        if (idleJudgeTimer) {
          clearTimeout(idleJudgeTimer);
          idleJudgeTimer = null;
        }
        agentObserved = null;
        updateTerminalObservedState();
        try {
          const WebglAddonCtor =
            window.WebglAddon &&
            (window.WebglAddon.WebglAddon || window.WebglAddon.default || window.WebglAddon);
          if (WebglAddonCtor) {
            webglAddon = new WebglAddonCtor();
            terminal.loadAddon(webglAddon);
            debugTerminal('webgl-addon', { enabled: true });
          }
        } catch (err) {
          debugTerminal('webgl-addon', { enabled: false, error: String(err) });
          webglAddon = null;
        }
        fitAddon.fit();
        lastResizeCols = terminal.cols;
        lastResizeRows = terminal.rows;
        terminal.focus();
        applyTerminalSettings();
        setupTerminalEvents();
        registerTerminalSession().finally(() => {
          startTerminalSession();
          resizeTerminal();
        });

        if (resizeObserver) {
          resizeObserver.disconnect();
        }
        resizeObserver = new ResizeObserver(() => {
          if (!fitAddon || !terminal) return;
          if (resizeDebounceTimer) {
            clearTimeout(resizeDebounceTimer);
          }
          resizeDebounceTimer = setTimeout(() => {
            resizeDebounceTimer = null;
            if (!fitAddon || !terminal) return;
            const beforeCols = terminal.cols;
            const beforeRows = terminal.rows;
            fitAddon.fit();
            if (terminal.cols === beforeCols && terminal.rows === beforeRows) return;
            if (terminal.cols === lastResizeCols && terminal.rows === lastResizeRows) return;
            if (focusTransitionActive) return;
            lastResizeCols = terminal.cols;
            lastResizeRows = terminal.rows;
            resizeTerminal();
          }, 75);
        });
        resizeObserver.observe(terminalContainer);

        terminalContainer.addEventListener('mousedown', (event) => {
          if (event && event.detail >= 2 && typeof event.preventDefault === 'function') {
            event.preventDefault();
          }
          terminal.focus();
        });
        terminalContainer.addEventListener('click', (event) => {
          if (!isTerminalView) return;
          if (!event || event.detail !== 1) return;
          void pickupCurrentTerminalWindowIfNeeded('click');
        });
        window.addEventListener('focus', () => {
          if (!isTerminalView) return;
          void pickupCurrentTerminalWindowIfNeeded('focus');
        });
        terminalContainer.addEventListener(
          'dblclick',
          async (event) => {
            if (!isTerminalView) return;
            if (event && typeof event.preventDefault === 'function') {
              event.preventDefault();
            }
            if (event && typeof event.stopPropagation === 'function') {
              event.stopPropagation();
            }
            const now = Date.now();
            if (now - terminalSurfaceDoubleClickAt < terminalSurfaceDoubleClickCooldownMs) {
              return;
            }
            if (terminalSurfaceSpawnInFlight) {
              return;
            }
            terminalSurfaceDoubleClickAt = now;
            terminalSurfaceSpawnInFlight = true;
            try {
              await openTerminalWindowSamePositionForSession(terminalSessionId);
            } finally {
              terminalSurfaceSpawnInFlight = false;
            }
          },
          { capture: true }
        );

        const listen = getEventListen();
        if (!listen) {
          console.debug('[terminal] listen unavailable');
        } else {
          console.debug('[terminal] listen registered', { sessionId: terminalSessionId });
          listen('terminal-focus-transition', (event) => {
            const payload = event && event.payload;
            if (!payload) return;
            if (payload.active) {
              focusTransitionToken = payload.token;
              focusTransitionActive = true;
              return;
            }
            if (focusTransitionToken !== payload.token) return;
            focusTransitionActive = false;
            focusTransitionToken = null;
            setTimeout(() => {
              if (!fitAddon || !terminal) return;
              fitAddon.fit();
              lastResizeCols = terminal.cols;
              lastResizeRows = terminal.rows;
              resizeTerminal();
            }, 0);
          });
          listen('terminal-output', (event) => {
            const payload = event && event.payload;
            if (!payload) {
              console.debug('[terminal] output ignored', { reason: 'missing payload' });
              return;
            }
            if (payload.session_id !== terminalSessionId) {
              console.debug('[terminal] output ignored', {
                sessionId: terminalSessionId,
                payloadSessionId: payload.session_id,
              });
              return;
            }
            setLastTerminalEvent('output', terminalLastChunkTail || 'chunk');
            if (debugTerminalEnabled) {
              console.debug('[terminal] output', {
                sessionId: payload.session_id,
                size: (payload.chunk || '').length,
                stream: payload.stream,
              });
            }
            debugTerminal('output-chunk', {
              size: (payload.chunk || '').length,
              preview: visualizeText(payload.chunk || ''),
              pendingLen: pendingEcho.length,
              suppressActive: suppressEchoActive,
            });
            const nextChunk = payload.chunk || '';
            if (nextChunk) {
              const now = Date.now();
              terminalLastOutputAt = now;
              terminalLastActivityAt = now;
              appendOutputTail(nextChunk);
              if (terminalStateDetector.tailForObservation) {
                terminalLastChunkTail = terminalStateDetector.tailForObservation(outputTailBuffer);
              } else {
                terminalLastChunkTail = outputTailBuffer || String(nextChunk);
              }
              scheduleIdleJudge('output');
              updateTerminalObservedState();
              enqueueTerminalOutput(nextChunk);
            }
          });
          listen('terminal-output-broadcast', (event) => {
            const payload = event && event.payload;
            if (!payload) {
              if (debugTerminalEnabled) {
                console.debug('[terminal] output broadcast ignored', { reason: 'missing payload' });
              }
              return;
            }
            if (debugTerminalEnabled) {
              console.debug('[terminal] output broadcast', {
                sessionId: payload.session_id,
                size: (payload.chunk || '').length,
                stream: payload.stream,
              });
            }
          });
            listen('terminal-exit', (event) => {
              const payload = event && event.payload;
              if (!payload) {
                console.debug('[terminal] exit ignored', { reason: 'missing payload' });
                return;
            }
            if (payload.session_id !== terminalSessionId) {
              console.debug('[terminal] exit ignored', {
                sessionId: terminalSessionId,
                payloadSessionId: payload.session_id,
              });
              return;
            }
            console.debug('[terminal] exit', {
              sessionId: payload.session_id,
              code: payload.exit_code,
            });
            setLastTerminalEvent('exit', payload.exit_code);
            const hasExitCode = Number.isFinite(payload.exit_code);
            terminalExitCode = hasExitCode ? payload.exit_code : 0;
            terminalSessionReady = false;
            agentSessionActive = false;
            agentSessionSource = null;
              if (idleJudgeTimer) {
                clearTimeout(idleJudgeTimer);
                idleJudgeTimer = null;
              }
              clearAgentObservedState('terminal exit');
              clearLatchedObserved();
              updateTerminalObservedState();
              const exitLabel = hasExitCode ? String(payload.exit_code) : 'unknown';
              enqueueTerminalOutput(`\r\n[exit ${exitLabel}]\r\n`);
            });
            listen('terminal-error', (event) => {
              const payload = event && event.payload;
              if (!payload) {
                console.debug('[terminal] error ignored', { reason: 'missing payload' });
                return;
            }
            if (payload.session_id !== terminalSessionId) {
              console.debug('[terminal] error ignored', {
                sessionId: terminalSessionId,
                payloadSessionId: payload.session_id,
              });
              return;
            }
            console.debug('[terminal] error', {
              sessionId: payload.session_id,
              message: payload.message,
            });
            setLastTerminalEvent('error', payload.message);
            terminalExitCode = 1;
            terminalSessionReady = false;
            agentSessionActive = false;
            agentSessionSource = null;
              if (idleJudgeTimer) {
                clearTimeout(idleJudgeTimer);
                idleJudgeTimer = null;
              }
              clearAgentObservedState('terminal error');
              clearLatchedObserved();
              updateTerminalObservedState();
              enqueueTerminalOutput(`\r\n[error ${payload.message}]\r\n`);
            });
          listen('completion-hook-state', (event) => {
            const payload = event && event.payload;
            if (!payload) return;
            const observed = handleHookEvent(payload);
            if (isTerminalView) return;
            if (!observed) return;
            switch (observed.state) {
              case TerminalObservation.success:
                setCharacterPhase('success');
                break;
              case TerminalObservation.fail:
                setCharacterPhase('error');
                break;
              case TerminalObservation.needInput:
                setCharacterPhase('need_input');
                break;
              default:
                break;
            }
          });
        }
      }

      function appendLine(text, kind) {
        const line = document.createElement('div');
        line.className = `output-line ${kind}`;
        line.textContent = text;
        output.appendChild(line);
        if (followEnabled) {
          output.scrollTop = output.scrollHeight;
        }
      }

      output.addEventListener('scroll', () => {
        const atBottom = output.scrollHeight - output.scrollTop - output.clientHeight < 8;
        if (!atBottom && followEnabled) {
          setFollow(false);
        }
        if (atBottom && !followEnabled) {
          setFollow(true);
        }
      });

      setFollow(followEnabled);

      followToggle.addEventListener('click', () => {
        setFollow(!followEnabled);
        if (followEnabled) {
          output.scrollTop = output.scrollHeight;
        }
      });

      sendBtn.addEventListener('click', () => {
        const text = input.value.trim();
        if (!text) return;
        appendLine(`[you] ${text}`, 'user');
        input.value = '';
      });

      input.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' && !event.shiftKey) {
          event.preventDefault();
          sendBtn.click();
        }
      });

      const tileSingleClickTimers = new WeakMap();
      const singleClickDelayMs = 240;

      async function runTileSingleClick(tile, index) {
        const alreadyFocused = tile.classList.contains('focused');
        tiles.forEach((item) => item.classList.remove('focused'));
        if (!alreadyFocused) {
          tile.classList.add('focused');
        }
        const picked = await pickupTerminalWindowByIndex(index);
        if (!picked) {
          await ensureTerminalWindow(tile.dataset.session);
        }
      }

      async function runTileDoubleClick(tile, index) {
        const picked = await pickupTerminalWindowByIndex(index);
        if (!picked) {
          await ensureTerminalWindow(tile.dataset.session);
        }
        const opened = await openTerminalWindowByIndexSamePosition(index);
        if (opened) {
          tiles.forEach((item) => item.classList.remove('focused'));
          tile.classList.add('focused');
        }
      }

      function clearTileSingleClickTimer(tile) {
        const timer = tileSingleClickTimers.get(tile);
        if (timer) {
          clearTimeout(timer);
          tileSingleClickTimers.delete(tile);
        }
      }

      tiles.forEach((tile, index) => {
        tile.addEventListener('click', (event) => {
          if (event.detail !== 1) return;
          clearTileSingleClickTimer(tile);
          const timer = setTimeout(async () => {
            tileSingleClickTimers.delete(tile);
            await runTileSingleClick(tile, index);
          }, singleClickDelayMs);
          tileSingleClickTimers.set(tile, timer);
        });

        tile.addEventListener('dblclick', async (event) => {
          event.preventDefault();
          clearTileSingleClickTimer(tile);
          await runTileDoubleClick(tile, index);
        });
      });

      const runArrange = document.querySelector('[data-role="run-arrange"]');
      if (runArrange) {
        runArrange.addEventListener('click', () => {
          arrangeWindows();
        });
      }

      if (isTerminalView) {
        window.addEventListener('keydown', (event) => {
          if (shortcutMatchesEvent(event, settingsState.terminal_keybind_focus_next)) {
            event.preventDefault();
            focusNextTerminal('next');
            return;
          }
          if (shortcutMatchesEvent(event, settingsState.terminal_keybind_focus_prev)) {
            event.preventDefault();
            focusNextTerminal('prev');
          }
        });
      }
      window.addEventListener('keydown', (event) => {
        if (settingsBoard && !settingsBoard.classList.contains('hidden')) return;
        if (!shortcutMatchesEvent(event, settingsState.terminal_keybind_arrange)) return;
        event.preventDefault();
        arrangeWindows();
      });

      phaseButtons.forEach((button) => {
        button.addEventListener('click', () => {
          phaseLabel.textContent = button.dataset.phase || 'idle';
        });
      });

      modeChips.forEach((chip) => {
        chip.addEventListener('click', () => {
          modeChips.forEach((item) => item.classList.remove('active'));
          chip.classList.add('active');
          const mode = chip.dataset.mode;
          applyView(mode || 'chat');
        });
      });

      function setToggleState(enabled, label) {
        if (!label) return;
        label.textContent = enabled ? t('toggle.on') : t('toggle.off');
        const toggle = label.closest('.toggle-switch');
        if (toggle) {
          toggle.dataset.state = enabled ? 'on' : 'off';
          toggle.setAttribute('aria-pressed', enabled ? 'true' : 'false');
        }
      }

      function setCodexHookStatus(text) {
        if (!codexHookStatus) return;
        codexHookStatus.textContent = text || '';
      }

      function refreshCharacterList() {
        if (!characterList) return;
        characterList.innerHTML = '';
        Array.from(characterBundles.values()).forEach((name) => {
          const card = document.createElement('div');
          card.className = 'character-card';
          card.textContent = name;
          characterList.appendChild(card);
        });
      }

      function setFontStatus(message) {
        if (!terminalFontStatus) return;
        terminalFontStatus.textContent = message || '';
      }

      function normalizeThemeMode(raw) {
        return raw === 'light' ? 'light' : 'dark';
      }

      function themePaletteDefault(mode) {
        return mode === 'light' ? 'light-sand' : 'dark-ink';
      }

      function normalizeThemePalette(mode, raw) {
        const normalizedMode = normalizeThemeMode(mode);
        const value = String(raw || '').trim().toLowerCase();
        const candidates = themePaletteOptions[normalizedMode] || [];
        const matched = candidates.find((item) => item.value === value);
        return matched ? matched.value : themePaletteDefault(normalizedMode);
      }

      function normalizeThemePreset(raw) {
        const value = String(raw || '').trim().toLowerCase();
        if (value.startsWith('light-') || value.startsWith('dark-')) {
          return value;
        }
        return '';
      }

      function normalizeBoolean(value, fallback) {
        if (typeof value === 'boolean') return value;
        if (typeof value === 'number') return value !== 0;
        if (typeof value === 'string') {
          const normalized = value.trim().toLowerCase();
          if (
            normalized === 'true' ||
            normalized === '1' ||
            normalized === 'on' ||
            normalized === 'enabled'
          ) {
            return true;
          }
          if (
            normalized === 'false' ||
            normalized === '0' ||
            normalized === 'off' ||
            normalized === 'disabled'
          ) {
            return false;
          }
        }
        return Boolean(fallback);
      }

      function themePresetToPair(preset, fallbackMode) {
        const normalizedPreset = normalizeThemePreset(preset);
        const mode = normalizedPreset.startsWith('light-')
          ? 'light'
          : normalizedPreset.startsWith('dark-')
          ? 'dark'
          : normalizeThemeMode(fallbackMode);
        const palette = normalizeThemePalette(mode, normalizedPreset || themePaletteDefault(mode));
        return { mode, palette };
      }

      function resolveThemePreset(mode, palette) {
        const normalizedMode = normalizeThemeMode(mode);
        return normalizeThemePalette(normalizedMode, palette);
      }

      function readStoredThemePreference() {
        try {
          const rawMode = localStorage.getItem('nagomi_theme_mode');
          const rawPalette = localStorage.getItem('nagomi_theme_palette');
          if (!rawMode && !rawPalette) return null;
          const mode = normalizeThemeMode(rawMode || 'dark');
          const palette = normalizeThemePalette(mode, rawPalette || themePaletteDefault(mode));
          return { mode, palette };
        } catch {
          return null;
        }
      }

      function normalizeTerminalShellKind(raw) {
        const value = String(raw || '').trim().toLowerCase();
        if (value === 'powershell' || value === 'wsl') return value;
        return 'cmd';
      }

      function applyTerminalRuntimeVisibility() {
        if (settingsWindowsCard) {
          settingsWindowsCard.classList.toggle('hidden', !isWindowsRuntime);
        }
        const useWsl =
          isWindowsRuntime && normalizeTerminalShellKind(settingsState.terminal_shell_kind) === 'wsl';
        if (terminalWslDistroRow) {
          terminalWslDistroRow.classList.toggle('hidden', !useWsl);
        }
      }

      function ensureWslDistroOption(value) {
        if (!terminalWslDistro) return;
        const key = String(value || '').trim();
        if (!key) return;
        const exists = Array.from(terminalWslDistro.options).some((option) => option.value === key);
        if (exists) return;
        const option = document.createElement('option');
        option.value = key;
        option.textContent = key;
        option.dataset.dynamic = '1';
        terminalWslDistro.appendChild(option);
      }

      async function loadWslDistros() {
        if (!isWindowsRuntime || !terminalWslDistro) return;
        if (wslDistrosLoaded || wslDistrosLoading) return;
        wslDistrosLoading = true;
        try {
          const distros = await invokeWithSession('list_wsl_distros');
          const current = String(settingsState.terminal_wsl_distro || '').trim();
          const first = terminalWslDistro.options[0] || null;
          terminalWslDistro.innerHTML = '';
          if (first) {
            terminalWslDistro.appendChild(first);
          } else {
            const option = document.createElement('option');
            option.value = '';
            option.textContent = t('settings.runtime.wsl_default');
            option.dataset.i18n = 'settings.runtime.wsl_default';
            terminalWslDistro.appendChild(option);
          }
          (Array.isArray(distros) ? distros : []).forEach((name) => {
            const key = String(name || '').trim();
            if (!key) return;
            const option = document.createElement('option');
            option.value = key;
            option.textContent = key;
            terminalWslDistro.appendChild(option);
          });
          ensureWslDistroOption(current);
          terminalWslDistro.value = current;
          wslDistrosLoaded = true;
        } catch {
          ensureWslDistroOption(settingsState.terminal_wsl_distro);
          terminalWslDistro.value = settingsState.terminal_wsl_distro || '';
        } finally {
          wslDistrosLoading = false;
        }
      }

      const fontMeasureCanvas = document.createElement('canvas');
      const fontMeasureCtx = fontMeasureCanvas.getContext('2d');

      function formatFontFamilyValue(family) {
        const safe = String(family || '').replace(/"/g, '\\"');
        if (!safe) return terminalSettingsDefaults.fontFamily;
        return `"${safe}", ${terminalSettingsDefaults.fontFamily}`;
      }

      function formatFontLabel(value) {
        const text = String(value || '').trim();
        if (!text) return 'custom';
        const first = text.split(',')[0].trim();
        return first.replace(/^["']|["']$/g, '') || 'custom';
      }

      function looksMonospaceFont(family) {
        if (!fontMeasureCtx) return true;
        const safe = String(family || '').replace(/"/g, '\\"');
        if (!safe) return true;
        const stack = `"${safe}", ${terminalSettingsDefaults.fontFamily}`;
        fontMeasureCtx.font = `16px ${stack}`;
        const samples = ['i', 'W', 'm', '0', '1', '_'];
        const widths = samples.map((ch) => fontMeasureCtx.measureText(ch).width);
        const max = Math.max(...widths);
        const min = Math.min(...widths);
        return max - min < 0.2;
      }

      function rebuildFontOptions(fontFamilies) {
        if (!terminalFont) return;
        const currentValue =
          settingsState.terminal_font_family || terminalSettingsDefaults.fontFamily;
        terminalFont.innerHTML = '';
        const seen = new Set();
        baseFontOptions.forEach((base) => {
          const option = document.createElement('option');
          option.value = base.value;
          option.textContent = base.label;
          terminalFont.appendChild(option);
          seen.add(base.value);
        });
        (fontFamilies || []).forEach((family) => {
          const value = formatFontFamilyValue(family);
          if (!value || seen.has(value)) return;
          const option = document.createElement('option');
          option.value = value;
          option.textContent = family;
          option.dataset.dynamic = '1';
          terminalFont.appendChild(option);
          seen.add(value);
        });
        ensureFontOption(currentValue);
        terminalFont.value = currentValue;
      }

      async function loadLocalFonts() {
        if (!terminalFont) return;
        if (typeof window.queryLocalFonts !== 'function') {
          setFontStatus(t('settings.font.status_unavailable'));
          return;
        }
        setFontStatus(t('settings.font.status_loading'));
        try {
          const fonts = await window.queryLocalFonts();
          const families = new Set();
          fonts.forEach((font) => {
            if (font && font.family) {
              families.add(font.family);
            }
          });
          const list = Array.from(families)
            .filter((family) => looksMonospaceFont(family))
            .sort((a, b) => a.localeCompare(b));
          rebuildFontOptions(list);
          setFontStatus(t('settings.font.status_loaded'));
        } catch (err) {
          console.warn('[settings] local fonts unavailable', err);
          setFontStatus(t('settings.font.status_failed'));
        }
      }

      function ensureFontOption(value) {
        if (!terminalFont || !value) return;
        const exists = Array.from(terminalFont.options).some(
          (option) => option.value === value
        );
        if (exists) return;
        const option = document.createElement('option');
        option.value = value;
        option.textContent = formatFontLabel(value);
        option.dataset.dynamic = '1';
        terminalFont.appendChild(option);
      }

      function applySettings(next) {
        if (!next) return;
        Object.assign(settingsState, next);
        settingsState.terminal_theme = normalizeThemeMode(settingsState.terminal_theme);
        settingsState.terminal_theme_palette = normalizeThemePalette(
          settingsState.terminal_theme,
          settingsState.terminal_theme_palette
        );
        const themePreset = resolveThemePreset(
          settingsState.terminal_theme,
          settingsState.terminal_theme_palette
        );
        settingsState.terminal_scrollback_lines = normalizeScrollback(
          settingsState.terminal_scrollback_lines
        );
        settingsState.terminal_internal_commands_enabled = normalizeBoolean(
          settingsState.terminal_internal_commands_enabled,
          true
        );
        settingsState.terminal_shell_kind = normalizeTerminalShellKind(
          settingsState.terminal_shell_kind
        );
        settingsState.terminal_wsl_distro = String(settingsState.terminal_wsl_distro || '').trim();
        settingsState.terminal_keybind_arrange = normalizeShortcutBinding(
          settingsState.terminal_keybind_arrange,
          terminalKeybindDefaults.arrange
        );
        settingsState.terminal_keybind_focus_next = normalizeShortcutBinding(
          settingsState.terminal_keybind_focus_next,
          terminalKeybindDefaults.focusNext
        );
        settingsState.terminal_keybind_focus_prev = normalizeShortcutBinding(
          settingsState.terminal_keybind_focus_prev,
          terminalKeybindDefaults.focusPrev
        );
        notifyEnabled = settingsState.notifications_enabled;
        audioEnabled = settingsState.audio_enabled;
        llmEnabled = settingsState.llm_enabled;
        terminalCopyOnSelect = settingsState.terminal_copy_on_select;
        terminalWatcherEnabled = settingsState.terminal_watcher_enabled;
        nagomiInternalEnabled = settingsState.terminal_internal_commands_enabled;
        if (!nagomiInternalEnabled) {
          resetNagomiInternalCapture();
        }
        if (notifyState) setToggleState(notifyEnabled, notifyState);
        if (audioState) setToggleState(audioEnabled, audioState);
        if (llmState) setToggleState(llmEnabled, llmState);
        if (characterWatcherState) setToggleState(terminalWatcherEnabled, characterWatcherState);
        if (terminalInternalCommandsState) {
          setToggleState(nagomiInternalEnabled, terminalInternalCommandsState);
        }
        if (volumeSlider) volumeSlider.value = settingsState.volume;
        if (silenceInput) silenceInput.value = settingsState.silence_timeout_ms;
        if (llmTool) llmTool.value = settingsState.llm_tool;
        if (characterUploaded) characterUploaded.textContent = settingsState.character_id;
        if (terminalTheme) terminalTheme.value = themePreset;
        if (terminalFont) {
          ensureFontOption(settingsState.terminal_font_family);
          terminalFont.value = settingsState.terminal_font_family;
        }
        if (terminalFontSize) terminalFontSize.value = settingsState.terminal_font_size;
        if (terminalScrollback) terminalScrollback.value = settingsState.terminal_scrollback_lines;
        if (terminalShellKind) terminalShellKind.value = settingsState.terminal_shell_kind;
        if (terminalWslDistro) {
          ensureWslDistroOption(settingsState.terminal_wsl_distro);
          terminalWslDistro.value = settingsState.terminal_wsl_distro;
        }
        if (keybindArrangeInput) keybindArrangeInput.value = settingsState.terminal_keybind_arrange;
        if (keybindFocusNextInput) {
          keybindFocusNextInput.value = settingsState.terminal_keybind_focus_next;
        }
        if (keybindFocusPrevInput) {
          keybindFocusPrevInput.value = settingsState.terminal_keybind_focus_prev;
        }
        if (terminalCopyState) setToggleState(terminalCopyOnSelect, terminalCopyState);
        if (settingsState.character_id) {
          characterBundles.add(settingsState.character_id);
        }
        refreshCharacterList();
        const retention = document.querySelector('[data-role="settings-log-retention"]');
        if (settingsState.log_retention_lines && retention) {
          retention.value = settingsState.log_retention_lines;
        }
        applySettingsTheme(settingsState.terminal_theme, settingsState.terminal_theme_palette);
        applyTerminalRuntimeVisibility();
        applyTerminalWatcherVisibility();
        applyTerminalSettings();
        updateTerminalDebugBadge();
      }

      function applySettingsTheme(theme, palette) {
        const normalizedMode = normalizeThemeMode(theme);
        const normalizedPalette = normalizeThemePalette(normalizedMode, palette);
        settingsState.terminal_theme = normalizedMode;
        settingsState.terminal_theme_palette = normalizedPalette;
        try {
          localStorage.setItem('nagomi_theme_mode', normalizedMode);
          localStorage.setItem('nagomi_theme_palette', normalizedPalette);
        } catch {
          // no-op
        }
        document.documentElement.dataset.theme = normalizedMode;
        document.documentElement.dataset.themePalette = normalizedPalette;
        if (settingsBoard) {
          settingsBoard.dataset.theme = normalizedMode;
          settingsBoard.dataset.themePalette = normalizedPalette;
        }
      }

      function registerSettingsListener() {
        const listen = getEventListen();
        if (!listen) return;
        listen('settings-updated', (event) => {
          const payload = event && event.payload;
          if (!payload) return;
          applySettings(payload);
          applyTerminalSettings();
        });
      }

      function registerWatcherListener() {
        if (!isWatcherView) return;
        const listen = getEventListen();
        if (!listen) return;
        listen('terminal-aggregate-state', (event) => {
          const payload = event && event.payload;
          if (!payload || !payload.state) return;
          applyTerminalObservedState(payload.state, payload.reason || payload.state);
        });
      }

      async function notifyWatcherWindowReady() {
        if (!isWatcherView || watcherReadyNotified) return;
        try {
          await invokeWithSession('watcher_window_ready');
          watcherReadyNotified = true;
        } catch {
          // retry on next requestAnimationFrame
        }
      }

      async function loadSettingsFromBackend() {
        try {
          return await invokeWithSession('load_settings');
        } catch {
          return null;
        }
      }

      function bootstrapIpcSession(retries) {
        const remaining = typeof retries === 'number' ? retries : 6;
        ensureIpcSession()
          .then((sessionId) => {
            if (sessionId) return;
            if (remaining <= 0) return;
            setTimeout(() => bootstrapIpcSession(remaining - 1), 500);
          })
          .catch(() => {
            if (remaining <= 0) return;
            setTimeout(() => bootstrapIpcSession(remaining - 1), 500);
          });
      }

      async function saveSettingsToBackend() {
        for (let attempt = 0; attempt < 4; attempt += 1) {
          try {
            await invokeWithSession('save_settings', { settings: settingsState });
            return;
          } catch {
            await new Promise((resolve) => setTimeout(resolve, 120));
          }
        }
      }

      if (notifyToggle) {
        setToggleState(notifyEnabled, notifyState);
        notifyToggle.addEventListener('click', () => {
          notifyEnabled = !notifyEnabled;
          setToggleState(notifyEnabled, notifyState);
          settingsState.notifications_enabled = notifyEnabled;
          saveSettingsToBackend();
        });
      }

      if (audioToggle) {
        setToggleState(audioEnabled, audioState);
        audioToggle.addEventListener('click', () => {
          audioEnabled = !audioEnabled;
          setToggleState(audioEnabled, audioState);
          settingsState.audio_enabled = audioEnabled;
          saveSettingsToBackend();
        });
      }

      if (llmToggle) {
        setToggleState(llmEnabled, llmState);
        llmToggle.addEventListener('click', () => {
          llmEnabled = !llmEnabled;
          setToggleState(llmEnabled, llmState);
          settingsState.llm_enabled = llmEnabled;
          saveSettingsToBackend();
        });
      }

      if (characterWatcherToggle) {
        setToggleState(terminalWatcherEnabled, characterWatcherState);
        characterWatcherToggle.addEventListener('click', () => {
          terminalWatcherEnabled = !terminalWatcherEnabled;
          setToggleState(terminalWatcherEnabled, characterWatcherState);
          settingsState.terminal_watcher_enabled = terminalWatcherEnabled;
          applyTerminalWatcherVisibility();
          saveSettingsToBackend();
        });
      }

      if (codexHookButton) {
        codexHookButton.addEventListener('click', async () => {
          setCodexHookStatus('導入中...');
          const result = await invokeWithSession('ensure_codex_hook');
          if (!result) {
            setCodexHookStatus('失敗');
            return;
          }
          switch (result.status) {
            case 'installed':
              setCodexHookStatus('導入済み');
              break;
            case 'already_installed':
              setCodexHookStatus('導入済み');
              break;
            case 'skipped_existing_notify':
              setCodexHookStatus('既存のnotifyを検出（変更なし）');
              break;
            case 'migrated_py_to_js':
              setCodexHookStatus('node版へ移行');
              break;
            default:
              setCodexHookStatus('失敗');
              break;
          }
        });
      }

      if (volumeSlider) {
        volumeSlider.addEventListener('input', () => {
          settingsState.volume = Number(volumeSlider.value);
          saveSettingsToBackend();
        });
      }

      if (silenceInput) {
        silenceInput.addEventListener('change', () => {
          settingsState.silence_timeout_ms = Number(silenceInput.value);
          saveSettingsToBackend();
        });
      }

      if (llmTool) {
        llmTool.addEventListener('change', () => {
          settingsState.llm_tool = llmTool.value;
          saveSettingsToBackend();
        });
      }

      const logRetentionInput = document.querySelector('[data-role="settings-log-retention"]');
      if (logRetentionInput) {
        logRetentionInput.addEventListener('change', () => {
          settingsState.log_retention_lines = Number(logRetentionInput.value);
          saveSettingsToBackend();
        });
      }

      if (characterUpload) {
        characterUpload.addEventListener('change', () => {
          const file = characterUpload.files && characterUpload.files[0];
          if (!file) {
            characterUploaded.textContent = 'no upload';
            return;
          }
          characterUploaded.textContent = file.name;
          const name = file.name.replace(/\.zip$/i, '');
          settingsState.character_id = name;
          if (characterList) {
            characterBundles.add(name);
            refreshCharacterList();
          }
          saveSettingsToBackend();
        });
      }

      if (terminalTheme) {
        terminalTheme.addEventListener('change', () => {
          const themePair = themePresetToPair(terminalTheme.value, settingsState.terminal_theme);
          settingsState.terminal_theme = themePair.mode;
          settingsState.terminal_theme_palette = themePair.palette;
          applySettingsTheme(settingsState.terminal_theme, settingsState.terminal_theme_palette);
          applyTerminalSettings();
          saveSettingsToBackend();
        });
      }

      if (terminalFont) {
        terminalFont.addEventListener('change', () => {
          settingsState.terminal_font_family =
            terminalFont.value || terminalSettingsDefaults.fontFamily;
          applyTerminalSettings();
          saveSettingsToBackend();
        });
      }

      if (terminalFontRefresh) {
        terminalFontRefresh.addEventListener('click', () => {
          loadLocalFonts();
        });
      }

      if (terminalFontSize) {
        terminalFontSize.addEventListener('change', () => {
          settingsState.terminal_font_size =
            Number(terminalFontSize.value) || terminalSettingsDefaults.fontSize;
          applyTerminalSettings();
          saveSettingsToBackend();
        });
      }

      if (terminalScrollback) {
        terminalScrollback.addEventListener('change', () => {
          settingsState.terminal_scrollback_lines = normalizeScrollback(terminalScrollback.value);
          terminalScrollback.value = settingsState.terminal_scrollback_lines;
          applyTerminalSettings();
          saveSettingsToBackend();
        });
      }

      if (terminalShellKind) {
        terminalShellKind.addEventListener('change', () => {
          settingsState.terminal_shell_kind = normalizeTerminalShellKind(terminalShellKind.value);
          applyTerminalRuntimeVisibility();
          if (settingsState.terminal_shell_kind === 'wsl') {
            loadWslDistros();
          }
          if (settingsState.terminal_shell_kind !== 'wsl') {
            settingsState.terminal_wsl_distro = '';
            if (terminalWslDistro) terminalWslDistro.value = '';
          }
          saveSettingsToBackend();
        });
      }

      if (terminalWslDistro) {
        terminalWslDistro.addEventListener('change', () => {
          settingsState.terminal_wsl_distro = String(terminalWslDistro.value || '').trim();
          saveSettingsToBackend();
        });
      }

      if (terminalInternalCommandsToggle) {
        terminalInternalCommandsToggle.addEventListener('click', () => {
          const next = !normalizeBoolean(settingsState.terminal_internal_commands_enabled, true);
          settingsState.terminal_internal_commands_enabled = next;
          nagomiInternalEnabled = next;
          if (!nagomiInternalEnabled) {
            resetNagomiInternalCapture();
          }
          if (terminalInternalCommandsState) {
            setToggleState(nagomiInternalEnabled, terminalInternalCommandsState);
          }
          saveSettingsToBackend();
        });
      }

      bindShortcutInput(
        keybindArrangeInput,
        'terminal_keybind_arrange',
        terminalKeybindDefaults.arrange
      );
      bindShortcutInput(
        keybindFocusNextInput,
        'terminal_keybind_focus_next',
        terminalKeybindDefaults.focusNext
      );
      bindShortcutInput(
        keybindFocusPrevInput,
        'terminal_keybind_focus_prev',
        terminalKeybindDefaults.focusPrev
      );

      if (terminalCopyToggle) {
        terminalCopyToggle.addEventListener('click', () => {
          terminalCopyOnSelect = !terminalCopyOnSelect;
          settingsState.terminal_copy_on_select = terminalCopyOnSelect;
          if (terminalCopyState) setToggleState(terminalCopyOnSelect, terminalCopyState);
          saveSettingsToBackend();
        });
      }

      if (terminalDebugSave) {
        terminalDebugSave.addEventListener('click', () => {
          appendDebugSnapshot();
        });
      }
      if (terminalDebugScreenshot) {
        terminalDebugScreenshot.addEventListener('click', () => {
          saveDebugScreenshot();
        });
      }
      if (terminalDebugToggle) {
        terminalDebugToggle.addEventListener('click', () => {
          applyTerminalDebugUiVisible(!terminalDebugUiVisible);
        });
      }

      registerTestHooks();
      registerSettingsListener();
      registerWatcherListener();

      const initialView = new URLSearchParams(window.location.search).get('view') || 'chat';
      bootstrapIpcSession(6);
      loadSettingsFromBackend().then((loaded) => {
        const next = loaded ? { ...loaded } : { ...settingsState };
        if (!loaded) {
          const storedTheme = readStoredThemePreference();
          if (storedTheme) {
            next.terminal_theme = storedTheme.mode;
            next.terminal_theme_palette = storedTheme.palette;
          }
        }
        applySettings(next);
        applyTerminalDebugUiVisible(loadTerminalDebugUiVisible());
        applyView(initialView);
      });
    </script>
  </body>
</html>
